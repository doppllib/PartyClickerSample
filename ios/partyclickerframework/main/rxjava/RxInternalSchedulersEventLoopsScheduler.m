//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "RxFunctionsAction0.h"
#include "RxInternalSchedulersEventLoopsScheduler.h"
#include "RxInternalSchedulersNewThreadWorker.h"
#include "RxInternalSchedulersScheduledAction.h"
#include "RxInternalUtilRxThreadFactory.h"
#include "RxInternalUtilSubscriptionList.h"
#include "RxScheduler.h"
#include "RxSubscription.h"
#include "RxSubscriptionsCompositeSubscription.h"
#include "RxSubscriptionsSubscriptions.h"
#include "java/lang/Integer.h"
#include "java/lang/Runtime.h"
#include "java/util/concurrent/ThreadFactory.h"
#include "java/util/concurrent/TimeUnit.h"
#include "java/util/concurrent/atomic/AtomicReference.h"

@interface RxInternalSchedulersEventLoopsScheduler_EventLoopWorker () {
 @public
  RxInternalUtilSubscriptionList *serial_;
  RxSubscriptionsCompositeSubscription *timed_;
  RxInternalUtilSubscriptionList *both_;
  RxInternalSchedulersEventLoopsScheduler_PoolWorker *poolWorker_;
}

@end

J2OBJC_FIELD_SETTER(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker, serial_, RxInternalUtilSubscriptionList *)
J2OBJC_FIELD_SETTER(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker, timed_, RxSubscriptionsCompositeSubscription *)
J2OBJC_FIELD_SETTER(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker, both_, RxInternalUtilSubscriptionList *)
J2OBJC_FIELD_SETTER(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker, poolWorker_, RxInternalSchedulersEventLoopsScheduler_PoolWorker *)

@interface RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1 : NSObject < RxFunctionsAction0 > {
 @public
  RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *this$0_;
  id<RxFunctionsAction0> val$action_;
}

- (instancetype)initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker:(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *)outer$
                                                         withRxFunctionsAction0:(id<RxFunctionsAction0>)capture$0;

- (void)call;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1)

__attribute__((unused)) static void RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1_initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1 *self, RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0);

__attribute__((unused)) static RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1 *new_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1_initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1 *create_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1_initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0);

@interface RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2 : NSObject < RxFunctionsAction0 > {
 @public
  RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *this$0_;
  id<RxFunctionsAction0> val$action_;
}

- (instancetype)initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker:(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *)outer$
                                                         withRxFunctionsAction0:(id<RxFunctionsAction0>)capture$0;

- (void)call;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2)

__attribute__((unused)) static void RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2_initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2 *self, RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0);

__attribute__((unused)) static RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2 *new_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2_initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0) NS_RETURNS_RETAINED;

__attribute__((unused)) static RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2 *create_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2_initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0);

J2OBJC_INITIALIZED_DEFN(RxInternalSchedulersEventLoopsScheduler)

NSString *RxInternalSchedulersEventLoopsScheduler_KEY_MAX_THREADS = @"rx.scheduler.max-computation-threads";
jint RxInternalSchedulersEventLoopsScheduler_MAX_THREADS;
RxInternalSchedulersEventLoopsScheduler_PoolWorker *RxInternalSchedulersEventLoopsScheduler_SHUTDOWN_WORKER;
RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *RxInternalSchedulersEventLoopsScheduler_NONE;

@implementation RxInternalSchedulersEventLoopsScheduler

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory {
  RxInternalSchedulersEventLoopsScheduler_initWithJavaUtilConcurrentThreadFactory_(self, threadFactory);
  return self;
}

- (RxScheduler_Worker *)createWorker {
  return create_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_initWithRxInternalSchedulersEventLoopsScheduler_PoolWorker_([((RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *) nil_chk([((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(pool_)) get])) getEventLoop]);
}

- (void)start {
  RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *update = create_RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool_initWithJavaUtilConcurrentThreadFactory_withInt_(threadFactory_, RxInternalSchedulersEventLoopsScheduler_MAX_THREADS);
  if (![((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(pool_)) compareAndSetWithId:RxInternalSchedulersEventLoopsScheduler_NONE withId:update]) {
    [update shutdown];
  }
}

- (void)shutdown {
  for (; ; ) {
    RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *curr = [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(pool_)) get];
    if (curr == RxInternalSchedulersEventLoopsScheduler_NONE) {
      return;
    }
    if ([pool_ compareAndSetWithId:curr withId:RxInternalSchedulersEventLoopsScheduler_NONE]) {
      [((RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *) nil_chk(curr)) shutdown];
      return;
    }
  }
}

- (id<RxSubscription>)scheduleDirectWithRxFunctionsAction0:(id<RxFunctionsAction0>)action {
  RxInternalSchedulersEventLoopsScheduler_PoolWorker *pw = [((RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *) nil_chk([((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(pool_)) get])) getEventLoop];
  return [((RxInternalSchedulersEventLoopsScheduler_PoolWorker *) nil_chk(pw)) scheduleActualWithRxFunctionsAction0:action withLong:-1 withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, NANOSECONDS)];
}

- (void)dealloc {
  RELEASE_(threadFactory_);
  RELEASE_(pool_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LRxScheduler_Worker;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LRxSubscription;", 0x1, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaUtilConcurrentThreadFactory:);
  methods[1].selector = @selector(createWorker);
  methods[2].selector = @selector(start);
  methods[3].selector = @selector(shutdown);
  methods[4].selector = @selector(scheduleDirectWithRxFunctionsAction0:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "KEY_MAX_THREADS", "LNSString;", .constantValue.asLong = 0, 0x18, -1, 3, -1, -1 },
    { "MAX_THREADS", "I", .constantValue.asLong = 0, 0x18, -1, 4, -1, -1 },
    { "SHUTDOWN_WORKER", "LRxInternalSchedulersEventLoopsScheduler_PoolWorker;", .constantValue.asLong = 0, 0x18, -1, 5, -1, -1 },
    { "NONE", "LRxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool;", .constantValue.asLong = 0, 0x18, -1, 6, -1, -1 },
    { "threadFactory_", "LJavaUtilConcurrentThreadFactory;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "pool_", "LJavaUtilConcurrentAtomicAtomicReference;", .constantValue.asLong = 0, 0x10, -1, -1, 7, -1 },
  };
  static const void *ptrTable[] = { "LJavaUtilConcurrentThreadFactory;", "scheduleDirect", "LRxFunctionsAction0;", &RxInternalSchedulersEventLoopsScheduler_KEY_MAX_THREADS, &RxInternalSchedulersEventLoopsScheduler_MAX_THREADS, &RxInternalSchedulersEventLoopsScheduler_SHUTDOWN_WORKER, &RxInternalSchedulersEventLoopsScheduler_NONE, "Ljava/util/concurrent/atomic/AtomicReference<Lrx/internal/schedulers/EventLoopsScheduler$FixedSchedulerPool;>;", "LRxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool;LRxInternalSchedulersEventLoopsScheduler_EventLoopWorker;LRxInternalSchedulersEventLoopsScheduler_PoolWorker;" };
  static const J2ObjcClassInfo _RxInternalSchedulersEventLoopsScheduler = { "EventLoopsScheduler", "rx.internal.schedulers", ptrTable, methods, fields, 7, 0x11, 5, 6, -1, 8, -1, -1, -1 };
  return &_RxInternalSchedulersEventLoopsScheduler;
}

+ (void)initialize {
  if (self == [RxInternalSchedulersEventLoopsScheduler class]) {
    {
      jint maxThreads = [((JavaLangInteger *) nil_chk(JavaLangInteger_getIntegerWithNSString_withInt_(RxInternalSchedulersEventLoopsScheduler_KEY_MAX_THREADS, 0))) intValue];
      jint cpuCount = [((JavaLangRuntime *) nil_chk(JavaLangRuntime_getRuntime())) availableProcessors];
      jint max;
      if (maxThreads <= 0 || maxThreads > cpuCount) {
        max = cpuCount;
      }
      else {
        max = maxThreads;
      }
      RxInternalSchedulersEventLoopsScheduler_MAX_THREADS = max;
    }
    {
      JreStrongAssignAndConsume(&RxInternalSchedulersEventLoopsScheduler_SHUTDOWN_WORKER, new_RxInternalSchedulersEventLoopsScheduler_PoolWorker_initWithJavaUtilConcurrentThreadFactory_(JreLoadStatic(RxInternalUtilRxThreadFactory, NONE)));
      [RxInternalSchedulersEventLoopsScheduler_SHUTDOWN_WORKER unsubscribe];
    }
    JreStrongAssignAndConsume(&RxInternalSchedulersEventLoopsScheduler_NONE, new_RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool_initWithJavaUtilConcurrentThreadFactory_withInt_(nil, 0));
    J2OBJC_SET_INITIALIZED(RxInternalSchedulersEventLoopsScheduler)
  }
}

@end

void RxInternalSchedulersEventLoopsScheduler_initWithJavaUtilConcurrentThreadFactory_(RxInternalSchedulersEventLoopsScheduler *self, id<JavaUtilConcurrentThreadFactory> threadFactory) {
  RxScheduler_init(self);
  JreStrongAssign(&self->threadFactory_, threadFactory);
  JreStrongAssignAndConsume(&self->pool_, new_JavaUtilConcurrentAtomicAtomicReference_initWithId_(RxInternalSchedulersEventLoopsScheduler_NONE));
  [self start];
}

RxInternalSchedulersEventLoopsScheduler *new_RxInternalSchedulersEventLoopsScheduler_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_NEW_IMPL(RxInternalSchedulersEventLoopsScheduler, initWithJavaUtilConcurrentThreadFactory_, threadFactory)
}

RxInternalSchedulersEventLoopsScheduler *create_RxInternalSchedulersEventLoopsScheduler_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersEventLoopsScheduler, initWithJavaUtilConcurrentThreadFactory_, threadFactory)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxInternalSchedulersEventLoopsScheduler)

@implementation RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory
                                                withInt:(jint)maxThreads {
  RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool_initWithJavaUtilConcurrentThreadFactory_withInt_(self, threadFactory, maxThreads);
  return self;
}

- (RxInternalSchedulersEventLoopsScheduler_PoolWorker *)getEventLoop {
  jint c = cores_;
  if (c == 0) {
    return JreLoadStatic(RxInternalSchedulersEventLoopsScheduler, SHUTDOWN_WORKER);
  }
  return IOSObjectArray_Get(nil_chk(eventLoops_), (jint) (n_++ % c));
}

- (void)shutdown {
  {
    IOSObjectArray *a__ = eventLoops_;
    RxInternalSchedulersEventLoopsScheduler_PoolWorker * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    RxInternalSchedulersEventLoopsScheduler_PoolWorker * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      RxInternalSchedulersEventLoopsScheduler_PoolWorker *w = *b__++;
      [((RxInternalSchedulersEventLoopsScheduler_PoolWorker *) nil_chk(w)) unsubscribe];
    }
  }
}

- (void)dealloc {
  RELEASE_(eventLoops_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "LRxInternalSchedulersEventLoopsScheduler_PoolWorker;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaUtilConcurrentThreadFactory:withInt:);
  methods[1].selector = @selector(getEventLoop);
  methods[2].selector = @selector(shutdown);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "cores_", "I", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "eventLoops_", "[LRxInternalSchedulersEventLoopsScheduler_PoolWorker;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "n_", "J", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaUtilConcurrentThreadFactory;I", "LRxInternalSchedulersEventLoopsScheduler;" };
  static const J2ObjcClassInfo _RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool = { "FixedSchedulerPool", "rx.internal.schedulers", ptrTable, methods, fields, 7, 0x18, 3, 3, 1, -1, -1, -1, -1 };
  return &_RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool;
}

@end

void RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool_initWithJavaUtilConcurrentThreadFactory_withInt_(RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *self, id<JavaUtilConcurrentThreadFactory> threadFactory, jint maxThreads) {
  NSObject_init(self);
  self->cores_ = maxThreads;
  JreStrongAssignAndConsume(&self->eventLoops_, [IOSObjectArray newArrayWithLength:maxThreads type:RxInternalSchedulersEventLoopsScheduler_PoolWorker_class_()]);
  for (jint i = 0; i < maxThreads; i++) {
    IOSObjectArray_SetAndConsume(self->eventLoops_, i, new_RxInternalSchedulersEventLoopsScheduler_PoolWorker_initWithJavaUtilConcurrentThreadFactory_(threadFactory));
  }
}

RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *new_RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool_initWithJavaUtilConcurrentThreadFactory_withInt_(id<JavaUtilConcurrentThreadFactory> threadFactory, jint maxThreads) {
  J2OBJC_NEW_IMPL(RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool, initWithJavaUtilConcurrentThreadFactory_withInt_, threadFactory, maxThreads)
}

RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *create_RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool_initWithJavaUtilConcurrentThreadFactory_withInt_(id<JavaUtilConcurrentThreadFactory> threadFactory, jint maxThreads) {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool, initWithJavaUtilConcurrentThreadFactory_withInt_, threadFactory, maxThreads)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool)

@implementation RxInternalSchedulersEventLoopsScheduler_EventLoopWorker

- (instancetype)initWithRxInternalSchedulersEventLoopsScheduler_PoolWorker:(RxInternalSchedulersEventLoopsScheduler_PoolWorker *)poolWorker {
  RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_initWithRxInternalSchedulersEventLoopsScheduler_PoolWorker_(self, poolWorker);
  return self;
}

- (void)unsubscribe {
  [((RxInternalUtilSubscriptionList *) nil_chk(both_)) unsubscribe];
}

- (jboolean)isUnsubscribed {
  return [((RxInternalUtilSubscriptionList *) nil_chk(both_)) isUnsubscribed];
}

- (id<RxSubscription>)scheduleWithRxFunctionsAction0:(id<RxFunctionsAction0>)action {
  if ([self isUnsubscribed]) {
    return RxSubscriptionsSubscriptions_unsubscribed();
  }
  return [((RxInternalSchedulersEventLoopsScheduler_PoolWorker *) nil_chk(poolWorker_)) scheduleActualWithRxFunctionsAction0:create_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1_initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_(self, action) withLong:0 withJavaUtilConcurrentTimeUnit:nil withRxInternalUtilSubscriptionList:serial_];
}

- (id<RxSubscription>)scheduleWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                                            withLong:(jlong)delayTime
                      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  if ([self isUnsubscribed]) {
    return RxSubscriptionsSubscriptions_unsubscribed();
  }
  return [((RxInternalSchedulersEventLoopsScheduler_PoolWorker *) nil_chk(poolWorker_)) scheduleActualWithRxFunctionsAction0:create_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2_initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_(self, action) withLong:delayTime withJavaUtilConcurrentTimeUnit:unit withRxSubscriptionsCompositeSubscription:timed_];
}

- (void)dealloc {
  RELEASE_(serial_);
  RELEASE_(timed_);
  RELEASE_(both_);
  RELEASE_(poolWorker_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LRxSubscription;", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "LRxSubscription;", 0x1, 1, 3, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithRxInternalSchedulersEventLoopsScheduler_PoolWorker:);
  methods[1].selector = @selector(unsubscribe);
  methods[2].selector = @selector(isUnsubscribed);
  methods[3].selector = @selector(scheduleWithRxFunctionsAction0:);
  methods[4].selector = @selector(scheduleWithRxFunctionsAction0:withLong:withJavaUtilConcurrentTimeUnit:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "serial_", "LRxInternalUtilSubscriptionList;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "timed_", "LRxSubscriptionsCompositeSubscription;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "both_", "LRxInternalUtilSubscriptionList;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "poolWorker_", "LRxInternalSchedulersEventLoopsScheduler_PoolWorker;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LRxInternalSchedulersEventLoopsScheduler_PoolWorker;", "schedule", "LRxFunctionsAction0;", "LRxFunctionsAction0;JLJavaUtilConcurrentTimeUnit;", "LRxInternalSchedulersEventLoopsScheduler;" };
  static const J2ObjcClassInfo _RxInternalSchedulersEventLoopsScheduler_EventLoopWorker = { "EventLoopWorker", "rx.internal.schedulers", ptrTable, methods, fields, 7, 0x18, 5, 4, 4, -1, -1, -1, -1 };
  return &_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker;
}

@end

void RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_initWithRxInternalSchedulersEventLoopsScheduler_PoolWorker_(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *self, RxInternalSchedulersEventLoopsScheduler_PoolWorker *poolWorker) {
  RxScheduler_Worker_init(self);
  JreStrongAssignAndConsume(&self->serial_, new_RxInternalUtilSubscriptionList_init());
  JreStrongAssignAndConsume(&self->timed_, new_RxSubscriptionsCompositeSubscription_init());
  JreStrongAssignAndConsume(&self->both_, new_RxInternalUtilSubscriptionList_initWithRxSubscriptionArray_([IOSObjectArray arrayWithObjects:(id[]){ self->serial_, self->timed_ } count:2 type:RxSubscription_class_()]));
  JreStrongAssign(&self->poolWorker_, poolWorker);
}

RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *new_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_initWithRxInternalSchedulersEventLoopsScheduler_PoolWorker_(RxInternalSchedulersEventLoopsScheduler_PoolWorker *poolWorker) {
  J2OBJC_NEW_IMPL(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker, initWithRxInternalSchedulersEventLoopsScheduler_PoolWorker_, poolWorker)
}

RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *create_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_initWithRxInternalSchedulersEventLoopsScheduler_PoolWorker_(RxInternalSchedulersEventLoopsScheduler_PoolWorker *poolWorker) {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker, initWithRxInternalSchedulersEventLoopsScheduler_PoolWorker_, poolWorker)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker)

@implementation RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1

- (instancetype)initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker:(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *)outer$
                                                         withRxFunctionsAction0:(id<RxFunctionsAction0>)capture$0 {
  RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1_initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_(self, outer$, capture$0);
  return self;
}

- (void)call {
  if ([this$0_ isUnsubscribed]) {
    return;
  }
  [((id<RxFunctionsAction0>) nil_chk(val$action_)) call];
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(val$action_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker:withRxFunctionsAction0:);
  methods[1].selector = @selector(call);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LRxInternalSchedulersEventLoopsScheduler_EventLoopWorker;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "val$action_", "LRxFunctionsAction0;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LRxInternalSchedulersEventLoopsScheduler_EventLoopWorker;", "scheduleWithRxFunctionsAction0:" };
  static const J2ObjcClassInfo _RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1 = { "", "rx.internal.schedulers", ptrTable, methods, fields, 7, 0x8018, 2, 2, 0, -1, 1, -1, -1 };
  return &_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1;
}

@end

void RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1_initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1 *self, RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0) {
  JreStrongAssign(&self->this$0_, outer$);
  JreStrongAssign(&self->val$action_, capture$0);
  NSObject_init(self);
}

RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1 *new_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1_initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0) {
  J2OBJC_NEW_IMPL(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1, initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_, outer$, capture$0)
}

RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1 *create_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1_initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0) {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_1, initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_, outer$, capture$0)
}

@implementation RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2

- (instancetype)initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker:(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *)outer$
                                                         withRxFunctionsAction0:(id<RxFunctionsAction0>)capture$0 {
  RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2_initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_(self, outer$, capture$0);
  return self;
}

- (void)call {
  if ([this$0_ isUnsubscribed]) {
    return;
  }
  [((id<RxFunctionsAction0>) nil_chk(val$action_)) call];
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(val$action_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker:withRxFunctionsAction0:);
  methods[1].selector = @selector(call);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LRxInternalSchedulersEventLoopsScheduler_EventLoopWorker;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "val$action_", "LRxFunctionsAction0;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LRxInternalSchedulersEventLoopsScheduler_EventLoopWorker;", "scheduleWithRxFunctionsAction0:withLong:withJavaUtilConcurrentTimeUnit:" };
  static const J2ObjcClassInfo _RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2 = { "", "rx.internal.schedulers", ptrTable, methods, fields, 7, 0x8018, 2, 2, 0, -1, 1, -1, -1 };
  return &_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2;
}

@end

void RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2_initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2 *self, RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0) {
  JreStrongAssign(&self->this$0_, outer$);
  JreStrongAssign(&self->val$action_, capture$0);
  NSObject_init(self);
}

RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2 *new_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2_initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0) {
  J2OBJC_NEW_IMPL(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2, initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_, outer$, capture$0)
}

RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2 *create_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2_initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *outer$, id<RxFunctionsAction0> capture$0) {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_2, initWithRxInternalSchedulersEventLoopsScheduler_EventLoopWorker_withRxFunctionsAction0_, outer$, capture$0)
}

@implementation RxInternalSchedulersEventLoopsScheduler_PoolWorker

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory {
  RxInternalSchedulersEventLoopsScheduler_PoolWorker_initWithJavaUtilConcurrentThreadFactory_(self, threadFactory);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaUtilConcurrentThreadFactory:);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LJavaUtilConcurrentThreadFactory;", "LRxInternalSchedulersEventLoopsScheduler;" };
  static const J2ObjcClassInfo _RxInternalSchedulersEventLoopsScheduler_PoolWorker = { "PoolWorker", "rx.internal.schedulers", ptrTable, methods, NULL, 7, 0x18, 1, 0, 1, -1, -1, -1, -1 };
  return &_RxInternalSchedulersEventLoopsScheduler_PoolWorker;
}

@end

void RxInternalSchedulersEventLoopsScheduler_PoolWorker_initWithJavaUtilConcurrentThreadFactory_(RxInternalSchedulersEventLoopsScheduler_PoolWorker *self, id<JavaUtilConcurrentThreadFactory> threadFactory) {
  RxInternalSchedulersNewThreadWorker_initWithJavaUtilConcurrentThreadFactory_(self, threadFactory);
}

RxInternalSchedulersEventLoopsScheduler_PoolWorker *new_RxInternalSchedulersEventLoopsScheduler_PoolWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_NEW_IMPL(RxInternalSchedulersEventLoopsScheduler_PoolWorker, initWithJavaUtilConcurrentThreadFactory_, threadFactory)
}

RxInternalSchedulersEventLoopsScheduler_PoolWorker *create_RxInternalSchedulersEventLoopsScheduler_PoolWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersEventLoopsScheduler_PoolWorker, initWithJavaUtilConcurrentThreadFactory_, threadFactory)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxInternalSchedulersEventLoopsScheduler_PoolWorker)
