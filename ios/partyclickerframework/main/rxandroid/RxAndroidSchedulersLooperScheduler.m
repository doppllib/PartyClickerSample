//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "AndroidOsHandler.h"
#include "AndroidOsLooper.h"
#include "AndroidOsMessage.h"
#include "J2ObjC_source.h"
#include "RxAndroidPluginsRxAndroidPlugins.h"
#include "RxAndroidPluginsRxAndroidSchedulersHook.h"
#include "RxAndroidSchedulersLooperScheduler.h"
#include "RxExceptionsOnErrorNotImplementedException.h"
#include "RxFunctionsAction0.h"
#include "RxPluginsRxJavaErrorHandler.h"
#include "RxPluginsRxJavaPlugins.h"
#include "RxScheduler.h"
#include "RxSubscription.h"
#include "RxSubscriptionsSubscriptions.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Thread.h"
#include "java/util/concurrent/TimeUnit.h"

@interface RxAndroidSchedulersLooperScheduler () {
 @public
  AndroidOsHandler *handler_;
}

@end

J2OBJC_FIELD_SETTER(RxAndroidSchedulersLooperScheduler, handler_, AndroidOsHandler *)

@interface RxAndroidSchedulersLooperScheduler_HandlerWorker () {
 @public
  AndroidOsHandler *handler_;
  RxAndroidPluginsRxAndroidSchedulersHook *hook_;
  volatile_jboolean unsubscribed_;
}

@end

J2OBJC_FIELD_SETTER(RxAndroidSchedulersLooperScheduler_HandlerWorker, handler_, AndroidOsHandler *)
J2OBJC_FIELD_SETTER(RxAndroidSchedulersLooperScheduler_HandlerWorker, hook_, RxAndroidPluginsRxAndroidSchedulersHook *)

@interface RxAndroidSchedulersLooperScheduler_ScheduledAction () {
 @public
  id<RxFunctionsAction0> action_;
  AndroidOsHandler *handler_;
  volatile_jboolean unsubscribed_;
}

@end

J2OBJC_FIELD_SETTER(RxAndroidSchedulersLooperScheduler_ScheduledAction, action_, id<RxFunctionsAction0>)
J2OBJC_FIELD_SETTER(RxAndroidSchedulersLooperScheduler_ScheduledAction, handler_, AndroidOsHandler *)

@implementation RxAndroidSchedulersLooperScheduler

- (instancetype)initWithAndroidOsLooper:(AndroidOsLooper *)looper {
  RxAndroidSchedulersLooperScheduler_initWithAndroidOsLooper_(self, looper);
  return self;
}

- (instancetype)initWithAndroidOsHandler:(AndroidOsHandler *)handler {
  RxAndroidSchedulersLooperScheduler_initWithAndroidOsHandler_(self, handler);
  return self;
}

- (RxScheduler_Worker *)createWorker {
  return create_RxAndroidSchedulersLooperScheduler_HandlerWorker_initWithAndroidOsHandler_(handler_);
}

- (void)dealloc {
  RELEASE_(handler_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 1, -1, -1, -1, -1 },
    { NULL, "LRxScheduler_Worker;", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithAndroidOsLooper:);
  methods[1].selector = @selector(initWithAndroidOsHandler:);
  methods[2].selector = @selector(createWorker);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "handler_", "LAndroidOsHandler;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LAndroidOsLooper;", "LAndroidOsHandler;", "LRxAndroidSchedulersLooperScheduler_HandlerWorker;LRxAndroidSchedulersLooperScheduler_ScheduledAction;" };
  static const J2ObjcClassInfo _RxAndroidSchedulersLooperScheduler = { "LooperScheduler", "rx.android.schedulers", ptrTable, methods, fields, 7, 0x0, 3, 1, -1, 2, -1, -1, -1 };
  return &_RxAndroidSchedulersLooperScheduler;
}

@end

void RxAndroidSchedulersLooperScheduler_initWithAndroidOsLooper_(RxAndroidSchedulersLooperScheduler *self, AndroidOsLooper *looper) {
  RxScheduler_init(self);
  JreStrongAssignAndConsume(&self->handler_, new_AndroidOsHandler_initWithAndroidOsLooper_(looper));
}

RxAndroidSchedulersLooperScheduler *new_RxAndroidSchedulersLooperScheduler_initWithAndroidOsLooper_(AndroidOsLooper *looper) {
  J2OBJC_NEW_IMPL(RxAndroidSchedulersLooperScheduler, initWithAndroidOsLooper_, looper)
}

RxAndroidSchedulersLooperScheduler *create_RxAndroidSchedulersLooperScheduler_initWithAndroidOsLooper_(AndroidOsLooper *looper) {
  J2OBJC_CREATE_IMPL(RxAndroidSchedulersLooperScheduler, initWithAndroidOsLooper_, looper)
}

void RxAndroidSchedulersLooperScheduler_initWithAndroidOsHandler_(RxAndroidSchedulersLooperScheduler *self, AndroidOsHandler *handler) {
  RxScheduler_init(self);
  JreStrongAssign(&self->handler_, handler);
}

RxAndroidSchedulersLooperScheduler *new_RxAndroidSchedulersLooperScheduler_initWithAndroidOsHandler_(AndroidOsHandler *handler) {
  J2OBJC_NEW_IMPL(RxAndroidSchedulersLooperScheduler, initWithAndroidOsHandler_, handler)
}

RxAndroidSchedulersLooperScheduler *create_RxAndroidSchedulersLooperScheduler_initWithAndroidOsHandler_(AndroidOsHandler *handler) {
  J2OBJC_CREATE_IMPL(RxAndroidSchedulersLooperScheduler, initWithAndroidOsHandler_, handler)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxAndroidSchedulersLooperScheduler)

@implementation RxAndroidSchedulersLooperScheduler_HandlerWorker

- (instancetype)initWithAndroidOsHandler:(AndroidOsHandler *)handler {
  RxAndroidSchedulersLooperScheduler_HandlerWorker_initWithAndroidOsHandler_(self, handler);
  return self;
}

- (void)unsubscribe {
  JreAssignVolatileBoolean(&unsubscribed_, true);
  [((AndroidOsHandler *) nil_chk(handler_)) removeCallbacksAndMessagesWithId:self];
}

- (jboolean)isUnsubscribed {
  return JreLoadVolatileBoolean(&unsubscribed_);
}

- (id<RxSubscription>)scheduleWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                                            withLong:(jlong)delayTime
                      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  if (JreLoadVolatileBoolean(&unsubscribed_)) {
    return RxSubscriptionsSubscriptions_unsubscribed();
  }
  action = [((RxAndroidPluginsRxAndroidSchedulersHook *) nil_chk(hook_)) onScheduleWithRxFunctionsAction0:action];
  RxAndroidSchedulersLooperScheduler_ScheduledAction *scheduledAction = create_RxAndroidSchedulersLooperScheduler_ScheduledAction_initWithRxFunctionsAction0_withAndroidOsHandler_(action, handler_);
  AndroidOsMessage *message = AndroidOsMessage_obtainWithAndroidOsHandler_withJavaLangRunnable_(handler_, scheduledAction);
  JreStrongAssign(&((AndroidOsMessage *) nil_chk(message))->obj_, self);
  [((AndroidOsHandler *) nil_chk(handler_)) sendMessageDelayedWithAndroidOsMessage:message withLong:[((JavaUtilConcurrentTimeUnit *) nil_chk(unit)) toMillisWithLong:delayTime]];
  if (JreLoadVolatileBoolean(&unsubscribed_)) {
    [handler_ removeCallbacksWithJavaLangRunnable:scheduledAction];
    return RxSubscriptionsSubscriptions_unsubscribed();
  }
  return scheduledAction;
}

- (id<RxSubscription>)scheduleWithRxFunctionsAction0:(id<RxFunctionsAction0>)action {
  return [self scheduleWithRxFunctionsAction0:action withLong:0 withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, MILLISECONDS)];
}

- (void)dealloc {
  RELEASE_(handler_);
  RELEASE_(hook_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LRxSubscription;", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "LRxSubscription;", 0x1, 1, 3, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithAndroidOsHandler:);
  methods[1].selector = @selector(unsubscribe);
  methods[2].selector = @selector(isUnsubscribed);
  methods[3].selector = @selector(scheduleWithRxFunctionsAction0:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[4].selector = @selector(scheduleWithRxFunctionsAction0:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "handler_", "LAndroidOsHandler;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "hook_", "LRxAndroidPluginsRxAndroidSchedulersHook;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "unsubscribed_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LAndroidOsHandler;", "schedule", "LRxFunctionsAction0;JLJavaUtilConcurrentTimeUnit;", "LRxFunctionsAction0;", "LRxAndroidSchedulersLooperScheduler;" };
  static const J2ObjcClassInfo _RxAndroidSchedulersLooperScheduler_HandlerWorker = { "HandlerWorker", "rx.android.schedulers", ptrTable, methods, fields, 7, 0x8, 5, 3, 4, -1, -1, -1, -1 };
  return &_RxAndroidSchedulersLooperScheduler_HandlerWorker;
}

@end

void RxAndroidSchedulersLooperScheduler_HandlerWorker_initWithAndroidOsHandler_(RxAndroidSchedulersLooperScheduler_HandlerWorker *self, AndroidOsHandler *handler) {
  RxScheduler_Worker_init(self);
  JreStrongAssign(&self->handler_, handler);
  JreStrongAssign(&self->hook_, [((RxAndroidPluginsRxAndroidPlugins *) nil_chk(RxAndroidPluginsRxAndroidPlugins_getInstance())) getSchedulersHook]);
}

RxAndroidSchedulersLooperScheduler_HandlerWorker *new_RxAndroidSchedulersLooperScheduler_HandlerWorker_initWithAndroidOsHandler_(AndroidOsHandler *handler) {
  J2OBJC_NEW_IMPL(RxAndroidSchedulersLooperScheduler_HandlerWorker, initWithAndroidOsHandler_, handler)
}

RxAndroidSchedulersLooperScheduler_HandlerWorker *create_RxAndroidSchedulersLooperScheduler_HandlerWorker_initWithAndroidOsHandler_(AndroidOsHandler *handler) {
  J2OBJC_CREATE_IMPL(RxAndroidSchedulersLooperScheduler_HandlerWorker, initWithAndroidOsHandler_, handler)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxAndroidSchedulersLooperScheduler_HandlerWorker)

@implementation RxAndroidSchedulersLooperScheduler_ScheduledAction

- (instancetype)initWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                      withAndroidOsHandler:(AndroidOsHandler *)handler {
  RxAndroidSchedulersLooperScheduler_ScheduledAction_initWithRxFunctionsAction0_withAndroidOsHandler_(self, action, handler);
  return self;
}

- (void)run {
  @try {
    [((id<RxFunctionsAction0>) nil_chk(action_)) call];
  }
  @catch (NSException *e) {
    JavaLangIllegalStateException *ie;
    if ([e isKindOfClass:[RxExceptionsOnErrorNotImplementedException class]]) {
      ie = create_JavaLangIllegalStateException_initWithNSString_withNSException_(@"Exception thrown on Scheduler.Worker thread. Add `onError` handling.", e);
    }
    else {
      ie = create_JavaLangIllegalStateException_initWithNSString_withNSException_(@"Fatal Exception thrown on Scheduler.Worker thread.", e);
    }
    [((RxPluginsRxJavaErrorHandler *) nil_chk([((RxPluginsRxJavaPlugins *) nil_chk(RxPluginsRxJavaPlugins_getInstance())) getErrorHandler])) handleErrorWithNSException:ie];
    JavaLangThread *thread = JavaLangThread_currentThread();
    [((id<JavaLangThread_UncaughtExceptionHandler>) nil_chk([((JavaLangThread *) nil_chk(thread)) getUncaughtExceptionHandler])) uncaughtExceptionWithJavaLangThread:thread withNSException:ie];
  }
}

- (void)unsubscribe {
  JreAssignVolatileBoolean(&unsubscribed_, true);
  [((AndroidOsHandler *) nil_chk(handler_)) removeCallbacksWithJavaLangRunnable:self];
}

- (jboolean)isUnsubscribed {
  return JreLoadVolatileBoolean(&unsubscribed_);
}

- (void)dealloc {
  RELEASE_(action_);
  RELEASE_(handler_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithRxFunctionsAction0:withAndroidOsHandler:);
  methods[1].selector = @selector(run);
  methods[2].selector = @selector(unsubscribe);
  methods[3].selector = @selector(isUnsubscribed);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "action_", "LRxFunctionsAction0;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "handler_", "LAndroidOsHandler;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "unsubscribed_", "Z", .constantValue.asLong = 0, 0x42, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LRxFunctionsAction0;LAndroidOsHandler;", "LRxAndroidSchedulersLooperScheduler;" };
  static const J2ObjcClassInfo _RxAndroidSchedulersLooperScheduler_ScheduledAction = { "ScheduledAction", "rx.android.schedulers", ptrTable, methods, fields, 7, 0x18, 4, 3, 1, -1, -1, -1, -1 };
  return &_RxAndroidSchedulersLooperScheduler_ScheduledAction;
}

@end

void RxAndroidSchedulersLooperScheduler_ScheduledAction_initWithRxFunctionsAction0_withAndroidOsHandler_(RxAndroidSchedulersLooperScheduler_ScheduledAction *self, id<RxFunctionsAction0> action, AndroidOsHandler *handler) {
  NSObject_init(self);
  JreStrongAssign(&self->action_, action);
  JreStrongAssign(&self->handler_, handler);
}

RxAndroidSchedulersLooperScheduler_ScheduledAction *new_RxAndroidSchedulersLooperScheduler_ScheduledAction_initWithRxFunctionsAction0_withAndroidOsHandler_(id<RxFunctionsAction0> action, AndroidOsHandler *handler) {
  J2OBJC_NEW_IMPL(RxAndroidSchedulersLooperScheduler_ScheduledAction, initWithRxFunctionsAction0_withAndroidOsHandler_, action, handler)
}

RxAndroidSchedulersLooperScheduler_ScheduledAction *create_RxAndroidSchedulersLooperScheduler_ScheduledAction_initWithRxFunctionsAction0_withAndroidOsHandler_(id<RxFunctionsAction0> action, AndroidOsHandler *handler) {
  J2OBJC_CREATE_IMPL(RxAndroidSchedulersLooperScheduler_ScheduledAction, initWithRxFunctionsAction0_withAndroidOsHandler_, action, handler)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxAndroidSchedulersLooperScheduler_ScheduledAction)
