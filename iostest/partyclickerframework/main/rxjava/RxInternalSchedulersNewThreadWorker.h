//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_RxInternalSchedulersNewThreadWorker")
#ifdef RESTRICT_RxInternalSchedulersNewThreadWorker
#define INCLUDE_ALL_RxInternalSchedulersNewThreadWorker 0
#else
#define INCLUDE_ALL_RxInternalSchedulersNewThreadWorker 1
#endif
#undef RESTRICT_RxInternalSchedulersNewThreadWorker

#if !defined (RxInternalSchedulersNewThreadWorker_) && (INCLUDE_ALL_RxInternalSchedulersNewThreadWorker || defined(INCLUDE_RxInternalSchedulersNewThreadWorker))
#define RxInternalSchedulersNewThreadWorker_

#define RESTRICT_RxScheduler 1
#define INCLUDE_RxScheduler_Worker 1
#include "RxScheduler.h"

#define RESTRICT_RxSubscription 1
#define INCLUDE_RxSubscription 1
#include "RxSubscription.h"

@class JavaLangReflectMethod;
@class JavaUtilConcurrentScheduledThreadPoolExecutor;
@class JavaUtilConcurrentTimeUnit;
@class RxInternalSchedulersScheduledAction;
@class RxInternalUtilSubscriptionList;
@class RxSubscriptionsCompositeSubscription;
@protocol JavaUtilConcurrentScheduledExecutorService;
@protocol JavaUtilConcurrentThreadFactory;
@protocol RxFunctionsAction0;

@interface RxInternalSchedulersNewThreadWorker : RxScheduler_Worker < RxSubscription > {
 @public
  volatile_jboolean isUnsubscribed_;
}

#pragma mark Public

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory;

+ (void)deregisterExecutorWithJavaUtilConcurrentScheduledExecutorService:(id<JavaUtilConcurrentScheduledExecutorService>)service;

- (jboolean)isUnsubscribed;

+ (void)registerExecutorWithJavaUtilConcurrentScheduledThreadPoolExecutor:(JavaUtilConcurrentScheduledThreadPoolExecutor *)service;

- (id<RxSubscription>)scheduleWithRxFunctionsAction0:(id<RxFunctionsAction0>)action;

- (id<RxSubscription>)scheduleWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                                            withLong:(jlong)delayTime
                      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

- (RxInternalSchedulersScheduledAction *)scheduleActualWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                                                                     withLong:(jlong)delayTime
                                               withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

- (RxInternalSchedulersScheduledAction *)scheduleActualWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                                                                     withLong:(jlong)delayTime
                                               withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                                     withRxSubscriptionsCompositeSubscription:(RxSubscriptionsCompositeSubscription *)parent;

- (RxInternalSchedulersScheduledAction *)scheduleActualWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                                                                     withLong:(jlong)delayTime
                                               withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                                           withRxInternalUtilSubscriptionList:(RxInternalUtilSubscriptionList *)parent;

+ (jboolean)tryEnableCancelPolicyWithJavaUtilConcurrentScheduledExecutorService:(id<JavaUtilConcurrentScheduledExecutorService>)executor;

- (void)unsubscribe;

#pragma mark Package-Private

+ (JavaLangReflectMethod *)findSetRemoveOnCancelPolicyMethodWithJavaUtilConcurrentScheduledExecutorService:(id<JavaUtilConcurrentScheduledExecutorService>)executor;

+ (void)purgeExecutors;

@end

J2OBJC_STATIC_INIT(RxInternalSchedulersNewThreadWorker)

inline jint RxInternalSchedulersNewThreadWorker_get_PURGE_FREQUENCY();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jint RxInternalSchedulersNewThreadWorker_PURGE_FREQUENCY;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(RxInternalSchedulersNewThreadWorker, PURGE_FREQUENCY, jint)

FOUNDATION_EXPORT void RxInternalSchedulersNewThreadWorker_registerExecutorWithJavaUtilConcurrentScheduledThreadPoolExecutor_(JavaUtilConcurrentScheduledThreadPoolExecutor *service);

FOUNDATION_EXPORT void RxInternalSchedulersNewThreadWorker_deregisterExecutorWithJavaUtilConcurrentScheduledExecutorService_(id<JavaUtilConcurrentScheduledExecutorService> service);

FOUNDATION_EXPORT void RxInternalSchedulersNewThreadWorker_purgeExecutors();

FOUNDATION_EXPORT jboolean RxInternalSchedulersNewThreadWorker_tryEnableCancelPolicyWithJavaUtilConcurrentScheduledExecutorService_(id<JavaUtilConcurrentScheduledExecutorService> executor);

FOUNDATION_EXPORT JavaLangReflectMethod *RxInternalSchedulersNewThreadWorker_findSetRemoveOnCancelPolicyMethodWithJavaUtilConcurrentScheduledExecutorService_(id<JavaUtilConcurrentScheduledExecutorService> executor);

FOUNDATION_EXPORT void RxInternalSchedulersNewThreadWorker_initWithJavaUtilConcurrentThreadFactory_(RxInternalSchedulersNewThreadWorker *self, id<JavaUtilConcurrentThreadFactory> threadFactory);

FOUNDATION_EXPORT RxInternalSchedulersNewThreadWorker *new_RxInternalSchedulersNewThreadWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxInternalSchedulersNewThreadWorker *create_RxInternalSchedulersNewThreadWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalSchedulersNewThreadWorker)

#endif

#pragma pop_macro("INCLUDE_ALL_RxInternalSchedulersNewThreadWorker")
