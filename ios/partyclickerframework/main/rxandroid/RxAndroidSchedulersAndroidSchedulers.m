//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "AndroidOsLooper.h"
#include "J2ObjC_source.h"
#include "RxAndroidPluginsRxAndroidPlugins.h"
#include "RxAndroidPluginsRxAndroidSchedulersHook.h"
#include "RxAndroidSchedulersAndroidSchedulers.h"
#include "RxAndroidSchedulersLooperScheduler.h"
#include "RxScheduler.h"
#include "java/lang/NullPointerException.h"
#include "java/util/concurrent/atomic/AtomicReference.h"

@interface RxAndroidSchedulersAndroidSchedulers () {
 @public
  RxScheduler *mainThreadScheduler_;
}

+ (RxAndroidSchedulersAndroidSchedulers *)getInstance;

- (instancetype)init;

@end

J2OBJC_FIELD_SETTER(RxAndroidSchedulersAndroidSchedulers, mainThreadScheduler_, RxScheduler *)

inline JavaUtilConcurrentAtomicAtomicReference *RxAndroidSchedulersAndroidSchedulers_get_INSTANCE();
static JavaUtilConcurrentAtomicAtomicReference *RxAndroidSchedulersAndroidSchedulers_INSTANCE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxAndroidSchedulersAndroidSchedulers, INSTANCE, JavaUtilConcurrentAtomicAtomicReference *)

__attribute__((unused)) static RxAndroidSchedulersAndroidSchedulers *RxAndroidSchedulersAndroidSchedulers_getInstance();

__attribute__((unused)) static void RxAndroidSchedulersAndroidSchedulers_init(RxAndroidSchedulersAndroidSchedulers *self);

__attribute__((unused)) static RxAndroidSchedulersAndroidSchedulers *new_RxAndroidSchedulersAndroidSchedulers_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static RxAndroidSchedulersAndroidSchedulers *create_RxAndroidSchedulersAndroidSchedulers_init();

J2OBJC_INITIALIZED_DEFN(RxAndroidSchedulersAndroidSchedulers)

@implementation RxAndroidSchedulersAndroidSchedulers

+ (RxAndroidSchedulersAndroidSchedulers *)getInstance {
  return RxAndroidSchedulersAndroidSchedulers_getInstance();
}

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  RxAndroidSchedulersAndroidSchedulers_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

+ (RxScheduler *)mainThread {
  return RxAndroidSchedulersAndroidSchedulers_mainThread();
}

+ (RxScheduler *)fromWithAndroidOsLooper:(AndroidOsLooper *)looper {
  return RxAndroidSchedulersAndroidSchedulers_fromWithAndroidOsLooper_(looper);
}

+ (void)reset {
  RxAndroidSchedulersAndroidSchedulers_reset();
}

- (void)dealloc {
  RELEASE_(mainThreadScheduler_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LRxAndroidSchedulersAndroidSchedulers;", 0xa, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LRxScheduler;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LRxScheduler;", 0x9, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x9, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(getInstance);
  methods[1].selector = @selector(init);
  methods[2].selector = @selector(mainThread);
  methods[3].selector = @selector(fromWithAndroidOsLooper:);
  methods[4].selector = @selector(reset);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "INSTANCE", "LJavaUtilConcurrentAtomicAtomicReference;", .constantValue.asLong = 0, 0x1a, -1, 2, 3, -1 },
    { "mainThreadScheduler_", "LRxScheduler;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "from", "LAndroidOsLooper;", &RxAndroidSchedulersAndroidSchedulers_INSTANCE, "Ljava/util/concurrent/atomic/AtomicReference<Lrx/android/schedulers/AndroidSchedulers;>;" };
  static const J2ObjcClassInfo _RxAndroidSchedulersAndroidSchedulers = { "AndroidSchedulers", "rx.android.schedulers", ptrTable, methods, fields, 7, 0x11, 5, 2, -1, -1, -1, -1, -1 };
  return &_RxAndroidSchedulersAndroidSchedulers;
}

+ (void)initialize {
  if (self == [RxAndroidSchedulersAndroidSchedulers class]) {
    JreStrongAssignAndConsume(&RxAndroidSchedulersAndroidSchedulers_INSTANCE, new_JavaUtilConcurrentAtomicAtomicReference_init());
    J2OBJC_SET_INITIALIZED(RxAndroidSchedulersAndroidSchedulers)
  }
}

@end

RxAndroidSchedulersAndroidSchedulers *RxAndroidSchedulersAndroidSchedulers_getInstance() {
  RxAndroidSchedulersAndroidSchedulers_initialize();
  for (; ; ) {
    RxAndroidSchedulersAndroidSchedulers *current = [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(RxAndroidSchedulersAndroidSchedulers_INSTANCE)) get];
    if (current != nil) {
      return current;
    }
    current = create_RxAndroidSchedulersAndroidSchedulers_init();
    if ([RxAndroidSchedulersAndroidSchedulers_INSTANCE compareAndSetWithId:nil withId:current]) {
      return current;
    }
  }
}

void RxAndroidSchedulersAndroidSchedulers_init(RxAndroidSchedulersAndroidSchedulers *self) {
  NSObject_init(self);
  RxAndroidPluginsRxAndroidSchedulersHook *hook = [((RxAndroidPluginsRxAndroidPlugins *) nil_chk(RxAndroidPluginsRxAndroidPlugins_getInstance())) getSchedulersHook];
  RxScheduler *main = [((RxAndroidPluginsRxAndroidSchedulersHook *) nil_chk(hook)) getMainThreadScheduler];
  if (main != nil) {
    JreStrongAssign(&self->mainThreadScheduler_, main);
  }
  else {
    JreStrongAssignAndConsume(&self->mainThreadScheduler_, new_RxAndroidSchedulersLooperScheduler_initWithAndroidOsLooper_(AndroidOsLooper_getMainLooper()));
  }
}

RxAndroidSchedulersAndroidSchedulers *new_RxAndroidSchedulersAndroidSchedulers_init() {
  J2OBJC_NEW_IMPL(RxAndroidSchedulersAndroidSchedulers, init)
}

RxAndroidSchedulersAndroidSchedulers *create_RxAndroidSchedulersAndroidSchedulers_init() {
  J2OBJC_CREATE_IMPL(RxAndroidSchedulersAndroidSchedulers, init)
}

RxScheduler *RxAndroidSchedulersAndroidSchedulers_mainThread() {
  RxAndroidSchedulersAndroidSchedulers_initialize();
  return ((RxAndroidSchedulersAndroidSchedulers *) nil_chk(RxAndroidSchedulersAndroidSchedulers_getInstance()))->mainThreadScheduler_;
}

RxScheduler *RxAndroidSchedulersAndroidSchedulers_fromWithAndroidOsLooper_(AndroidOsLooper *looper) {
  RxAndroidSchedulersAndroidSchedulers_initialize();
  if (looper == nil) @throw create_JavaLangNullPointerException_initWithNSString_(@"looper == null");
  return create_RxAndroidSchedulersLooperScheduler_initWithAndroidOsLooper_(looper);
}

void RxAndroidSchedulersAndroidSchedulers_reset() {
  RxAndroidSchedulersAndroidSchedulers_initialize();
  [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(RxAndroidSchedulersAndroidSchedulers_INSTANCE)) setWithId:nil];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxAndroidSchedulersAndroidSchedulers)
