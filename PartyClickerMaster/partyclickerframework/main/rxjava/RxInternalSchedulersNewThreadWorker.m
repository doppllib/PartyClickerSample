//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "RxExceptionsExceptions.h"
#include "RxFunctionsAction0.h"
#include "RxInternalSchedulersNewThreadWorker.h"
#include "RxInternalSchedulersScheduledAction.h"
#include "RxInternalUtilPlatformDependent.h"
#include "RxInternalUtilRxThreadFactory.h"
#include "RxInternalUtilSubscriptionList.h"
#include "RxPluginsRxJavaHooks.h"
#include "RxScheduler.h"
#include "RxSubscription.h"
#include "RxSubscriptionsCompositeSubscription.h"
#include "RxSubscriptionsSubscriptions.h"
#include "java/lang/Boolean.h"
#include "java/lang/IllegalAccessException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/Runnable.h"
#include "java/lang/reflect/InvocationTargetException.h"
#include "java/lang/reflect/Method.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"
#include "java/util/Set.h"
#include "java/util/concurrent/ConcurrentHashMap.h"
#include "java/util/concurrent/Executors.h"
#include "java/util/concurrent/Future.h"
#include "java/util/concurrent/ScheduledExecutorService.h"
#include "java/util/concurrent/ScheduledFuture.h"
#include "java/util/concurrent/ScheduledThreadPoolExecutor.h"
#include "java/util/concurrent/ThreadFactory.h"
#include "java/util/concurrent/TimeUnit.h"
#include "java/util/concurrent/atomic/AtomicReference.h"

@interface RxInternalSchedulersNewThreadWorker () {
 @public
  id<JavaUtilConcurrentScheduledExecutorService> executor_;
}

@end

J2OBJC_FIELD_SETTER(RxInternalSchedulersNewThreadWorker, executor_, id<JavaUtilConcurrentScheduledExecutorService>)

inline NSString *RxInternalSchedulersNewThreadWorker_get_FREQUENCY_KEY();
static NSString *RxInternalSchedulersNewThreadWorker_FREQUENCY_KEY = @"rx.scheduler.jdk6.purge-frequency-millis";
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersNewThreadWorker, FREQUENCY_KEY, NSString *)

inline NSString *RxInternalSchedulersNewThreadWorker_get_PURGE_FORCE_KEY();
static NSString *RxInternalSchedulersNewThreadWorker_PURGE_FORCE_KEY = @"rx.scheduler.jdk6.purge-force";
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersNewThreadWorker, PURGE_FORCE_KEY, NSString *)

inline NSString *RxInternalSchedulersNewThreadWorker_get_PURGE_THREAD_PREFIX();
static NSString *RxInternalSchedulersNewThreadWorker_PURGE_THREAD_PREFIX = @"RxSchedulerPurge-";
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersNewThreadWorker, PURGE_THREAD_PREFIX, NSString *)

inline jboolean RxInternalSchedulersNewThreadWorker_get_SHOULD_TRY_ENABLE_CANCEL_POLICY();
static jboolean RxInternalSchedulersNewThreadWorker_SHOULD_TRY_ENABLE_CANCEL_POLICY;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(RxInternalSchedulersNewThreadWorker, SHOULD_TRY_ENABLE_CANCEL_POLICY, jboolean)

inline JavaUtilConcurrentConcurrentHashMap *RxInternalSchedulersNewThreadWorker_get_EXECUTORS();
static JavaUtilConcurrentConcurrentHashMap *RxInternalSchedulersNewThreadWorker_EXECUTORS;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersNewThreadWorker, EXECUTORS, JavaUtilConcurrentConcurrentHashMap *)

inline JavaUtilConcurrentAtomicAtomicReference *RxInternalSchedulersNewThreadWorker_get_PURGE();
static JavaUtilConcurrentAtomicAtomicReference *RxInternalSchedulersNewThreadWorker_PURGE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersNewThreadWorker, PURGE, JavaUtilConcurrentAtomicAtomicReference *)

inline id RxInternalSchedulersNewThreadWorker_get_cachedSetRemoveOnCancelPolicyMethod();
inline id RxInternalSchedulersNewThreadWorker_set_cachedSetRemoveOnCancelPolicyMethod(id value);
static volatile_id RxInternalSchedulersNewThreadWorker_cachedSetRemoveOnCancelPolicyMethod;
J2OBJC_STATIC_FIELD_OBJ_VOLATILE(RxInternalSchedulersNewThreadWorker, cachedSetRemoveOnCancelPolicyMethod, id)

inline id RxInternalSchedulersNewThreadWorker_get_SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED();
static id RxInternalSchedulersNewThreadWorker_SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersNewThreadWorker, SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED, id)

@interface RxInternalSchedulersNewThreadWorker_1 : NSObject < JavaLangRunnable >

- (instancetype)init;

- (void)run;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalSchedulersNewThreadWorker_1)

__attribute__((unused)) static void RxInternalSchedulersNewThreadWorker_1_init(RxInternalSchedulersNewThreadWorker_1 *self);

__attribute__((unused)) static RxInternalSchedulersNewThreadWorker_1 *new_RxInternalSchedulersNewThreadWorker_1_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static RxInternalSchedulersNewThreadWorker_1 *create_RxInternalSchedulersNewThreadWorker_1_init();

J2OBJC_INITIALIZED_DEFN(RxInternalSchedulersNewThreadWorker)

jint RxInternalSchedulersNewThreadWorker_PURGE_FREQUENCY;

@implementation RxInternalSchedulersNewThreadWorker

+ (void)registerExecutorWithJavaUtilConcurrentScheduledThreadPoolExecutor:(JavaUtilConcurrentScheduledThreadPoolExecutor *)service {
  RxInternalSchedulersNewThreadWorker_registerExecutorWithJavaUtilConcurrentScheduledThreadPoolExecutor_(service);
}

+ (void)deregisterExecutorWithJavaUtilConcurrentScheduledExecutorService:(id<JavaUtilConcurrentScheduledExecutorService>)service {
  RxInternalSchedulersNewThreadWorker_deregisterExecutorWithJavaUtilConcurrentScheduledExecutorService_(service);
}

+ (void)purgeExecutors {
  RxInternalSchedulersNewThreadWorker_purgeExecutors();
}

+ (jboolean)tryEnableCancelPolicyWithJavaUtilConcurrentScheduledExecutorService:(id<JavaUtilConcurrentScheduledExecutorService>)executor {
  return RxInternalSchedulersNewThreadWorker_tryEnableCancelPolicyWithJavaUtilConcurrentScheduledExecutorService_(executor);
}

+ (JavaLangReflectMethod *)findSetRemoveOnCancelPolicyMethodWithJavaUtilConcurrentScheduledExecutorService:(id<JavaUtilConcurrentScheduledExecutorService>)executor {
  return RxInternalSchedulersNewThreadWorker_findSetRemoveOnCancelPolicyMethodWithJavaUtilConcurrentScheduledExecutorService_(executor);
}

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory {
  RxInternalSchedulersNewThreadWorker_initWithJavaUtilConcurrentThreadFactory_(self, threadFactory);
  return self;
}

- (id<RxSubscription>)scheduleWithRxFunctionsAction0:(id<RxFunctionsAction0>)action {
  return [self scheduleWithRxFunctionsAction0:action withLong:0 withJavaUtilConcurrentTimeUnit:nil];
}

- (id<RxSubscription>)scheduleWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                                            withLong:(jlong)delayTime
                      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  if (JreLoadVolatileBoolean(&isUnsubscribed_)) {
    return RxSubscriptionsSubscriptions_unsubscribed();
  }
  return [self scheduleActualWithRxFunctionsAction0:action withLong:delayTime withJavaUtilConcurrentTimeUnit:unit];
}

- (RxInternalSchedulersScheduledAction *)scheduleActualWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                                                                     withLong:(jlong)delayTime
                                               withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit {
  id<RxFunctionsAction0> decoratedAction = RxPluginsRxJavaHooks_onScheduledActionWithRxFunctionsAction0_(action);
  RxInternalSchedulersScheduledAction *run = create_RxInternalSchedulersScheduledAction_initWithRxFunctionsAction0_(decoratedAction);
  id<JavaUtilConcurrentFuture> f;
  if (delayTime <= 0) {
    f = [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(executor_)) submitWithJavaLangRunnable:run];
  }
  else {
    f = [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(executor_)) scheduleWithJavaLangRunnable:run withLong:delayTime withJavaUtilConcurrentTimeUnit:unit];
  }
  [run addWithJavaUtilConcurrentFuture:f];
  return run;
}

- (RxInternalSchedulersScheduledAction *)scheduleActualWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                                                                     withLong:(jlong)delayTime
                                               withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                                     withRxSubscriptionsCompositeSubscription:(RxSubscriptionsCompositeSubscription *)parent {
  id<RxFunctionsAction0> decoratedAction = RxPluginsRxJavaHooks_onScheduledActionWithRxFunctionsAction0_(action);
  RxInternalSchedulersScheduledAction *run = create_RxInternalSchedulersScheduledAction_initWithRxFunctionsAction0_withRxSubscriptionsCompositeSubscription_(decoratedAction, parent);
  [((RxSubscriptionsCompositeSubscription *) nil_chk(parent)) addWithRxSubscription:run];
  id<JavaUtilConcurrentFuture> f;
  if (delayTime <= 0) {
    f = [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(executor_)) submitWithJavaLangRunnable:run];
  }
  else {
    f = [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(executor_)) scheduleWithJavaLangRunnable:run withLong:delayTime withJavaUtilConcurrentTimeUnit:unit];
  }
  [run addWithJavaUtilConcurrentFuture:f];
  return run;
}

- (RxInternalSchedulersScheduledAction *)scheduleActualWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                                                                     withLong:(jlong)delayTime
                                               withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit
                                           withRxInternalUtilSubscriptionList:(RxInternalUtilSubscriptionList *)parent {
  id<RxFunctionsAction0> decoratedAction = RxPluginsRxJavaHooks_onScheduledActionWithRxFunctionsAction0_(action);
  RxInternalSchedulersScheduledAction *run = create_RxInternalSchedulersScheduledAction_initWithRxFunctionsAction0_withRxInternalUtilSubscriptionList_(decoratedAction, parent);
  [((RxInternalUtilSubscriptionList *) nil_chk(parent)) addWithRxSubscription:run];
  id<JavaUtilConcurrentFuture> f;
  if (delayTime <= 0) {
    f = [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(executor_)) submitWithJavaLangRunnable:run];
  }
  else {
    f = [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(executor_)) scheduleWithJavaLangRunnable:run withLong:delayTime withJavaUtilConcurrentTimeUnit:unit];
  }
  [run addWithJavaUtilConcurrentFuture:f];
  return run;
}

- (void)unsubscribe {
  JreAssignVolatileBoolean(&isUnsubscribed_, true);
  [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(executor_)) shutdownNow];
  RxInternalSchedulersNewThreadWorker_deregisterExecutorWithJavaUtilConcurrentScheduledExecutorService_(executor_);
}

- (jboolean)isUnsubscribed {
  return JreLoadVolatileBoolean(&isUnsubscribed_);
}

- (void)dealloc {
  RELEASE_(executor_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x9, 0, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x9, 2, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x8, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x9, 4, 3, -1, -1, -1, -1 },
    { NULL, "LJavaLangReflectMethod;", 0x8, 5, 3, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 6, -1, -1, -1, -1 },
    { NULL, "LRxSubscription;", 0x1, 7, 8, -1, -1, -1, -1 },
    { NULL, "LRxSubscription;", 0x1, 7, 9, -1, -1, -1, -1 },
    { NULL, "LRxInternalSchedulersScheduledAction;", 0x1, 10, 9, -1, -1, -1, -1 },
    { NULL, "LRxInternalSchedulersScheduledAction;", 0x1, 10, 11, -1, -1, -1, -1 },
    { NULL, "LRxInternalSchedulersScheduledAction;", 0x1, 10, 12, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(registerExecutorWithJavaUtilConcurrentScheduledThreadPoolExecutor:);
  methods[1].selector = @selector(deregisterExecutorWithJavaUtilConcurrentScheduledExecutorService:);
  methods[2].selector = @selector(purgeExecutors);
  methods[3].selector = @selector(tryEnableCancelPolicyWithJavaUtilConcurrentScheduledExecutorService:);
  methods[4].selector = @selector(findSetRemoveOnCancelPolicyMethodWithJavaUtilConcurrentScheduledExecutorService:);
  methods[5].selector = @selector(initWithJavaUtilConcurrentThreadFactory:);
  methods[6].selector = @selector(scheduleWithRxFunctionsAction0:);
  methods[7].selector = @selector(scheduleWithRxFunctionsAction0:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[8].selector = @selector(scheduleActualWithRxFunctionsAction0:withLong:withJavaUtilConcurrentTimeUnit:);
  methods[9].selector = @selector(scheduleActualWithRxFunctionsAction0:withLong:withJavaUtilConcurrentTimeUnit:withRxSubscriptionsCompositeSubscription:);
  methods[10].selector = @selector(scheduleActualWithRxFunctionsAction0:withLong:withJavaUtilConcurrentTimeUnit:withRxInternalUtilSubscriptionList:);
  methods[11].selector = @selector(unsubscribe);
  methods[12].selector = @selector(isUnsubscribed);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "executor_", "LJavaUtilConcurrentScheduledExecutorService;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "isUnsubscribed_", "Z", .constantValue.asLong = 0, 0x40, -1, -1, -1, -1 },
    { "FREQUENCY_KEY", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 13, -1, -1 },
    { "PURGE_FORCE_KEY", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 14, -1, -1 },
    { "PURGE_THREAD_PREFIX", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 15, -1, -1 },
    { "SHOULD_TRY_ENABLE_CANCEL_POLICY", "Z", .constantValue.asLong = 0, 0x1a, -1, 16, -1, -1 },
    { "PURGE_FREQUENCY", "I", .constantValue.asLong = 0, 0x19, -1, 17, -1, -1 },
    { "EXECUTORS", "LJavaUtilConcurrentConcurrentHashMap;", .constantValue.asLong = 0, 0x1a, -1, 18, 19, -1 },
    { "PURGE", "LJavaUtilConcurrentAtomicAtomicReference;", .constantValue.asLong = 0, 0x1a, -1, 20, 21, -1 },
    { "cachedSetRemoveOnCancelPolicyMethod", "LNSObject;", .constantValue.asLong = 0, 0x4a, -1, 22, -1, -1 },
    { "SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED", "LNSObject;", .constantValue.asLong = 0, 0x1a, -1, 23, -1, -1 },
  };
  static const void *ptrTable[] = { "registerExecutor", "LJavaUtilConcurrentScheduledThreadPoolExecutor;", "deregisterExecutor", "LJavaUtilConcurrentScheduledExecutorService;", "tryEnableCancelPolicy", "findSetRemoveOnCancelPolicyMethod", "LJavaUtilConcurrentThreadFactory;", "schedule", "LRxFunctionsAction0;", "LRxFunctionsAction0;JLJavaUtilConcurrentTimeUnit;", "scheduleActual", "LRxFunctionsAction0;JLJavaUtilConcurrentTimeUnit;LRxSubscriptionsCompositeSubscription;", "LRxFunctionsAction0;JLJavaUtilConcurrentTimeUnit;LRxInternalUtilSubscriptionList;", &RxInternalSchedulersNewThreadWorker_FREQUENCY_KEY, &RxInternalSchedulersNewThreadWorker_PURGE_FORCE_KEY, &RxInternalSchedulersNewThreadWorker_PURGE_THREAD_PREFIX, &RxInternalSchedulersNewThreadWorker_SHOULD_TRY_ENABLE_CANCEL_POLICY, &RxInternalSchedulersNewThreadWorker_PURGE_FREQUENCY, &RxInternalSchedulersNewThreadWorker_EXECUTORS, "Ljava/util/concurrent/ConcurrentHashMap<Ljava/util/concurrent/ScheduledThreadPoolExecutor;Ljava/util/concurrent/ScheduledThreadPoolExecutor;>;", &RxInternalSchedulersNewThreadWorker_PURGE, "Ljava/util/concurrent/atomic/AtomicReference<Ljava/util/concurrent/ScheduledExecutorService;>;", &RxInternalSchedulersNewThreadWorker_cachedSetRemoveOnCancelPolicyMethod, &RxInternalSchedulersNewThreadWorker_SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED };
  static const J2ObjcClassInfo _RxInternalSchedulersNewThreadWorker = { "NewThreadWorker", "rx.internal.schedulers", ptrTable, methods, fields, 7, 0x1, 13, 11, -1, -1, -1, -1, -1 };
  return &_RxInternalSchedulersNewThreadWorker;
}

+ (void)initialize {
  if (self == [RxInternalSchedulersNewThreadWorker class]) {
    JreStrongAssignAndConsume(&RxInternalSchedulersNewThreadWorker_SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED, new_NSObject_init());
    {
      JreStrongAssignAndConsume(&RxInternalSchedulersNewThreadWorker_EXECUTORS, new_JavaUtilConcurrentConcurrentHashMap_init());
      JreStrongAssignAndConsume(&RxInternalSchedulersNewThreadWorker_PURGE, new_JavaUtilConcurrentAtomicAtomicReference_init());
      RxInternalSchedulersNewThreadWorker_PURGE_FREQUENCY = [((JavaLangInteger *) nil_chk(JavaLangInteger_getIntegerWithNSString_withInt_(RxInternalSchedulersNewThreadWorker_FREQUENCY_KEY, 1000))) intValue];
      jboolean purgeForce = JavaLangBoolean_getBooleanWithNSString_(RxInternalSchedulersNewThreadWorker_PURGE_FORCE_KEY);
      jint androidApiVersion = RxInternalUtilPlatformDependent_getAndroidApiVersion();
      RxInternalSchedulersNewThreadWorker_SHOULD_TRY_ENABLE_CANCEL_POLICY = (!purgeForce && (androidApiVersion == RxInternalUtilPlatformDependent_ANDROID_API_VERSION_IS_NOT_ANDROID || androidApiVersion >= 21));
    }
    J2OBJC_SET_INITIALIZED(RxInternalSchedulersNewThreadWorker)
  }
}

@end

void RxInternalSchedulersNewThreadWorker_registerExecutorWithJavaUtilConcurrentScheduledThreadPoolExecutor_(JavaUtilConcurrentScheduledThreadPoolExecutor *service) {
  RxInternalSchedulersNewThreadWorker_initialize();
  do {
    id<JavaUtilConcurrentScheduledExecutorService> exec = [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(RxInternalSchedulersNewThreadWorker_PURGE)) get];
    if (exec != nil) {
      break;
    }
    exec = JavaUtilConcurrentExecutors_newScheduledThreadPoolWithInt_withJavaUtilConcurrentThreadFactory_(1, create_RxInternalUtilRxThreadFactory_initWithNSString_(RxInternalSchedulersNewThreadWorker_PURGE_THREAD_PREFIX));
    if ([RxInternalSchedulersNewThreadWorker_PURGE compareAndSetWithId:nil withId:exec]) {
      [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(exec)) scheduleAtFixedRateWithJavaLangRunnable:create_RxInternalSchedulersNewThreadWorker_1_init() withLong:RxInternalSchedulersNewThreadWorker_PURGE_FREQUENCY withLong:RxInternalSchedulersNewThreadWorker_PURGE_FREQUENCY withJavaUtilConcurrentTimeUnit:JreLoadEnum(JavaUtilConcurrentTimeUnit, MILLISECONDS)];
      break;
    }
    else {
      [((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(exec)) shutdownNow];
    }
  }
  while (true);
  [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(RxInternalSchedulersNewThreadWorker_EXECUTORS)) putIfAbsentWithId:service withId:service];
}

void RxInternalSchedulersNewThreadWorker_deregisterExecutorWithJavaUtilConcurrentScheduledExecutorService_(id<JavaUtilConcurrentScheduledExecutorService> service) {
  RxInternalSchedulersNewThreadWorker_initialize();
  [((JavaUtilConcurrentConcurrentHashMap *) nil_chk(RxInternalSchedulersNewThreadWorker_EXECUTORS)) removeWithId:service];
}

void RxInternalSchedulersNewThreadWorker_purgeExecutors() {
  RxInternalSchedulersNewThreadWorker_initialize();
  @try {
    id<JavaUtilIterator> it = [((id<JavaUtilSet>) nil_chk([((JavaUtilConcurrentConcurrentHashMap *) nil_chk(RxInternalSchedulersNewThreadWorker_EXECUTORS)) keySet])) iterator];
    while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
      JavaUtilConcurrentScheduledThreadPoolExecutor *exec = [it next];
      if (![((JavaUtilConcurrentScheduledThreadPoolExecutor *) nil_chk(exec)) isShutdown]) {
        [exec purge];
      }
      else {
        [it remove];
      }
    }
  }
  @catch (NSException *t) {
    RxExceptionsExceptions_throwIfFatalWithNSException_(t);
    RxPluginsRxJavaHooks_onErrorWithNSException_(t);
  }
}

jboolean RxInternalSchedulersNewThreadWorker_tryEnableCancelPolicyWithJavaUtilConcurrentScheduledExecutorService_(id<JavaUtilConcurrentScheduledExecutorService> executor) {
  RxInternalSchedulersNewThreadWorker_initialize();
  if (RxInternalSchedulersNewThreadWorker_SHOULD_TRY_ENABLE_CANCEL_POLICY) {
    jboolean isInstanceOfScheduledThreadPoolExecutor = [executor isKindOfClass:[JavaUtilConcurrentScheduledThreadPoolExecutor class]];
    JavaLangReflectMethod *methodToCall;
    if (isInstanceOfScheduledThreadPoolExecutor) {
      id localSetRemoveOnCancelPolicyMethod = JreLoadVolatileId(&RxInternalSchedulersNewThreadWorker_cachedSetRemoveOnCancelPolicyMethod);
      if (localSetRemoveOnCancelPolicyMethod == RxInternalSchedulersNewThreadWorker_SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED) {
        return false;
      }
      if (localSetRemoveOnCancelPolicyMethod == nil) {
        JavaLangReflectMethod *method = RxInternalSchedulersNewThreadWorker_findSetRemoveOnCancelPolicyMethodWithJavaUtilConcurrentScheduledExecutorService_(executor);
        JreVolatileStrongAssign(&RxInternalSchedulersNewThreadWorker_cachedSetRemoveOnCancelPolicyMethod, method != nil ? method : RxInternalSchedulersNewThreadWorker_SET_REMOVE_ON_CANCEL_POLICY_METHOD_NOT_SUPPORTED);
        methodToCall = method;
      }
      else {
        methodToCall = (JavaLangReflectMethod *) cast_chk(localSetRemoveOnCancelPolicyMethod, [JavaLangReflectMethod class]);
      }
    }
    else {
      methodToCall = RxInternalSchedulersNewThreadWorker_findSetRemoveOnCancelPolicyMethodWithJavaUtilConcurrentScheduledExecutorService_(executor);
    }
    if (methodToCall != nil) {
      @try {
        [methodToCall invokeWithId:executor withNSObjectArray:[IOSObjectArray arrayWithObjects:(id[]){ JavaLangBoolean_valueOfWithBoolean_(true) } count:1 type:NSObject_class_()]];
        return true;
      }
      @catch (JavaLangReflectInvocationTargetException *e) {
        RxPluginsRxJavaHooks_onErrorWithNSException_(e);
      }
      @catch (JavaLangIllegalAccessException *e) {
        RxPluginsRxJavaHooks_onErrorWithNSException_(e);
      }
      @catch (JavaLangIllegalArgumentException *e) {
        RxPluginsRxJavaHooks_onErrorWithNSException_(e);
      }
    }
  }
  return false;
}

JavaLangReflectMethod *RxInternalSchedulersNewThreadWorker_findSetRemoveOnCancelPolicyMethodWithJavaUtilConcurrentScheduledExecutorService_(id<JavaUtilConcurrentScheduledExecutorService> executor) {
  RxInternalSchedulersNewThreadWorker_initialize();
  {
    IOSObjectArray *a__ = [[((id<JavaUtilConcurrentScheduledExecutorService>) nil_chk(executor)) java_getClass] getMethods];
    JavaLangReflectMethod * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    JavaLangReflectMethod * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      JavaLangReflectMethod *method = *b__++;
      if ([((NSString *) nil_chk([((JavaLangReflectMethod *) nil_chk(method)) getName])) isEqual:@"setRemoveOnCancelPolicy"]) {
        IOSObjectArray *parameterTypes = [method getParameterTypes];
        if (((IOSObjectArray *) nil_chk(parameterTypes))->size_ == 1 && IOSObjectArray_Get(parameterTypes, 0) == JreLoadStatic(JavaLangBoolean, TYPE)) {
          return method;
        }
      }
    }
  }
  return nil;
}

void RxInternalSchedulersNewThreadWorker_initWithJavaUtilConcurrentThreadFactory_(RxInternalSchedulersNewThreadWorker *self, id<JavaUtilConcurrentThreadFactory> threadFactory) {
  RxScheduler_Worker_init(self);
  id<JavaUtilConcurrentScheduledExecutorService> exec = JavaUtilConcurrentExecutors_newScheduledThreadPoolWithInt_withJavaUtilConcurrentThreadFactory_(1, threadFactory);
  jboolean cancelSupported = RxInternalSchedulersNewThreadWorker_tryEnableCancelPolicyWithJavaUtilConcurrentScheduledExecutorService_(exec);
  if (!cancelSupported && [exec isKindOfClass:[JavaUtilConcurrentScheduledThreadPoolExecutor class]]) {
    RxInternalSchedulersNewThreadWorker_registerExecutorWithJavaUtilConcurrentScheduledThreadPoolExecutor_((JavaUtilConcurrentScheduledThreadPoolExecutor *) cast_chk(exec, [JavaUtilConcurrentScheduledThreadPoolExecutor class]));
  }
  JreStrongAssign(&self->executor_, exec);
}

RxInternalSchedulersNewThreadWorker *new_RxInternalSchedulersNewThreadWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_NEW_IMPL(RxInternalSchedulersNewThreadWorker, initWithJavaUtilConcurrentThreadFactory_, threadFactory)
}

RxInternalSchedulersNewThreadWorker *create_RxInternalSchedulersNewThreadWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersNewThreadWorker, initWithJavaUtilConcurrentThreadFactory_, threadFactory)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxInternalSchedulersNewThreadWorker)

@implementation RxInternalSchedulersNewThreadWorker_1

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  RxInternalSchedulersNewThreadWorker_1_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)run {
  RxInternalSchedulersNewThreadWorker_purgeExecutors();
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(run);
  #pragma clang diagnostic pop
  static const void *ptrTable[] = { "LRxInternalSchedulersNewThreadWorker;", "registerExecutorWithJavaUtilConcurrentScheduledThreadPoolExecutor:" };
  static const J2ObjcClassInfo _RxInternalSchedulersNewThreadWorker_1 = { "", "rx.internal.schedulers", ptrTable, methods, NULL, 7, 0x8018, 2, 0, 0, -1, 1, -1, -1 };
  return &_RxInternalSchedulersNewThreadWorker_1;
}

@end

void RxInternalSchedulersNewThreadWorker_1_init(RxInternalSchedulersNewThreadWorker_1 *self) {
  NSObject_init(self);
}

RxInternalSchedulersNewThreadWorker_1 *new_RxInternalSchedulersNewThreadWorker_1_init() {
  J2OBJC_NEW_IMPL(RxInternalSchedulersNewThreadWorker_1, init)
}

RxInternalSchedulersNewThreadWorker_1 *create_RxInternalSchedulersNewThreadWorker_1_init() {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersNewThreadWorker_1, init)
}
