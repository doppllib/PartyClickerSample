//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "J2ObjC_source.h"
#include "RxExceptionsExceptions.h"
#include "RxFunctionsAction0.h"
#include "RxInternalSchedulersSleepingAction.h"
#include "RxScheduler.h"
#include "java/lang/InterruptedException.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/Thread.h"

@interface RxInternalSchedulersSleepingAction () {
 @public
  id<RxFunctionsAction0> underlying_;
  RxScheduler_Worker *innerScheduler_;
  jlong execTime_;
}

@end

J2OBJC_FIELD_SETTER(RxInternalSchedulersSleepingAction, underlying_, id<RxFunctionsAction0>)
J2OBJC_FIELD_SETTER(RxInternalSchedulersSleepingAction, innerScheduler_, RxScheduler_Worker *)

@implementation RxInternalSchedulersSleepingAction

- (instancetype)initWithRxFunctionsAction0:(id<RxFunctionsAction0>)underlying
                    withRxScheduler_Worker:(RxScheduler_Worker *)scheduler
                                  withLong:(jlong)execTime {
  RxInternalSchedulersSleepingAction_initWithRxFunctionsAction0_withRxScheduler_Worker_withLong_(self, underlying, scheduler, execTime);
  return self;
}

- (void)call {
  if ([((RxScheduler_Worker *) nil_chk(innerScheduler_)) isUnsubscribed]) {
    return;
  }
  jlong delay = execTime_ - [innerScheduler_ now];
  if (delay > 0) {
    @try {
      JavaLangThread_sleepWithLong_(delay);
    }
    @catch (JavaLangInterruptedException *e) {
      [((JavaLangThread *) nil_chk(JavaLangThread_currentThread())) interrupt];
      RxExceptionsExceptions_propagateWithNSException_(e);
    }
  }
  if ([innerScheduler_ isUnsubscribed]) {
    return;
  }
  [((id<RxFunctionsAction0>) nil_chk(underlying_)) call];
}

- (void)dealloc {
  RELEASE_(underlying_);
  RELEASE_(innerScheduler_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithRxFunctionsAction0:withRxScheduler_Worker:withLong:);
  methods[1].selector = @selector(call);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "underlying_", "LRxFunctionsAction0;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "innerScheduler_", "LRxScheduler_Worker;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "execTime_", "J", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LRxFunctionsAction0;LRxScheduler_Worker;J" };
  static const J2ObjcClassInfo _RxInternalSchedulersSleepingAction = { "SleepingAction", "rx.internal.schedulers", ptrTable, methods, fields, 7, 0x0, 2, 3, -1, -1, -1, -1, -1 };
  return &_RxInternalSchedulersSleepingAction;
}

@end

void RxInternalSchedulersSleepingAction_initWithRxFunctionsAction0_withRxScheduler_Worker_withLong_(RxInternalSchedulersSleepingAction *self, id<RxFunctionsAction0> underlying, RxScheduler_Worker *scheduler, jlong execTime) {
  NSObject_init(self);
  JreStrongAssign(&self->underlying_, underlying);
  JreStrongAssign(&self->innerScheduler_, scheduler);
  self->execTime_ = execTime;
}

RxInternalSchedulersSleepingAction *new_RxInternalSchedulersSleepingAction_initWithRxFunctionsAction0_withRxScheduler_Worker_withLong_(id<RxFunctionsAction0> underlying, RxScheduler_Worker *scheduler, jlong execTime) {
  J2OBJC_NEW_IMPL(RxInternalSchedulersSleepingAction, initWithRxFunctionsAction0_withRxScheduler_Worker_withLong_, underlying, scheduler, execTime)
}

RxInternalSchedulersSleepingAction *create_RxInternalSchedulersSleepingAction_initWithRxFunctionsAction0_withRxScheduler_Worker_withLong_(id<RxFunctionsAction0> underlying, RxScheduler_Worker *scheduler, jlong execTime) {
  J2OBJC_CREATE_IMPL(RxInternalSchedulersSleepingAction, initWithRxFunctionsAction0_withRxScheduler_Worker_withLong_, underlying, scheduler, execTime)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxInternalSchedulersSleepingAction)
