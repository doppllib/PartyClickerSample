//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_RxInternalSchedulersEventLoopsScheduler")
#ifdef RESTRICT_RxInternalSchedulersEventLoopsScheduler
#define INCLUDE_ALL_RxInternalSchedulersEventLoopsScheduler 0
#else
#define INCLUDE_ALL_RxInternalSchedulersEventLoopsScheduler 1
#endif
#undef RESTRICT_RxInternalSchedulersEventLoopsScheduler

#if !defined (RxInternalSchedulersEventLoopsScheduler_) && (INCLUDE_ALL_RxInternalSchedulersEventLoopsScheduler || defined(INCLUDE_RxInternalSchedulersEventLoopsScheduler))
#define RxInternalSchedulersEventLoopsScheduler_

#define RESTRICT_RxScheduler 1
#define INCLUDE_RxScheduler 1
#include "RxScheduler.h"

#define RESTRICT_RxInternalSchedulersSchedulerLifecycle 1
#define INCLUDE_RxInternalSchedulersSchedulerLifecycle 1
#include "RxInternalSchedulersSchedulerLifecycle.h"

@class JavaUtilConcurrentAtomicAtomicReference;
@class RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool;
@class RxInternalSchedulersEventLoopsScheduler_PoolWorker;
@class RxScheduler_Worker;
@protocol JavaUtilConcurrentThreadFactory;
@protocol RxFunctionsAction0;
@protocol RxSubscription;

@interface RxInternalSchedulersEventLoopsScheduler : RxScheduler < RxInternalSchedulersSchedulerLifecycle > {
 @public
  id<JavaUtilConcurrentThreadFactory> threadFactory_;
  JavaUtilConcurrentAtomicAtomicReference *pool_;
}

#pragma mark Public

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory;

- (RxScheduler_Worker *)createWorker;

- (id<RxSubscription>)scheduleDirectWithRxFunctionsAction0:(id<RxFunctionsAction0>)action;

- (void)shutdown;

- (void)start;

@end

J2OBJC_STATIC_INIT(RxInternalSchedulersEventLoopsScheduler)

J2OBJC_FIELD_SETTER(RxInternalSchedulersEventLoopsScheduler, threadFactory_, id<JavaUtilConcurrentThreadFactory>)
J2OBJC_FIELD_SETTER(RxInternalSchedulersEventLoopsScheduler, pool_, JavaUtilConcurrentAtomicAtomicReference *)

inline NSString *RxInternalSchedulersEventLoopsScheduler_get_KEY_MAX_THREADS();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *RxInternalSchedulersEventLoopsScheduler_KEY_MAX_THREADS;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersEventLoopsScheduler, KEY_MAX_THREADS, NSString *)

inline jint RxInternalSchedulersEventLoopsScheduler_get_MAX_THREADS();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jint RxInternalSchedulersEventLoopsScheduler_MAX_THREADS;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(RxInternalSchedulersEventLoopsScheduler, MAX_THREADS, jint)

inline RxInternalSchedulersEventLoopsScheduler_PoolWorker *RxInternalSchedulersEventLoopsScheduler_get_SHUTDOWN_WORKER();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler_PoolWorker *RxInternalSchedulersEventLoopsScheduler_SHUTDOWN_WORKER;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersEventLoopsScheduler, SHUTDOWN_WORKER, RxInternalSchedulersEventLoopsScheduler_PoolWorker *)

inline RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *RxInternalSchedulersEventLoopsScheduler_get_NONE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *RxInternalSchedulersEventLoopsScheduler_NONE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(RxInternalSchedulersEventLoopsScheduler, NONE, RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *)

FOUNDATION_EXPORT void RxInternalSchedulersEventLoopsScheduler_initWithJavaUtilConcurrentThreadFactory_(RxInternalSchedulersEventLoopsScheduler *self, id<JavaUtilConcurrentThreadFactory> threadFactory);

FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler *new_RxInternalSchedulersEventLoopsScheduler_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler *create_RxInternalSchedulersEventLoopsScheduler_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalSchedulersEventLoopsScheduler)

#endif

#if !defined (RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool_) && (INCLUDE_ALL_RxInternalSchedulersEventLoopsScheduler || defined(INCLUDE_RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool))
#define RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool_

@class IOSObjectArray;
@class RxInternalSchedulersEventLoopsScheduler_PoolWorker;
@protocol JavaUtilConcurrentThreadFactory;

@interface RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool : NSObject {
 @public
  jint cores_;
  IOSObjectArray *eventLoops_;
  jlong n_;
}

#pragma mark Public

- (RxInternalSchedulersEventLoopsScheduler_PoolWorker *)getEventLoop;

- (void)shutdown;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory
                                                withInt:(jint)maxThreads;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool)

J2OBJC_FIELD_SETTER(RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool, eventLoops_, IOSObjectArray *)

FOUNDATION_EXPORT void RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool_initWithJavaUtilConcurrentThreadFactory_withInt_(RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *self, id<JavaUtilConcurrentThreadFactory> threadFactory, jint maxThreads);

FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *new_RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool_initWithJavaUtilConcurrentThreadFactory_withInt_(id<JavaUtilConcurrentThreadFactory> threadFactory, jint maxThreads) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool *create_RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool_initWithJavaUtilConcurrentThreadFactory_withInt_(id<JavaUtilConcurrentThreadFactory> threadFactory, jint maxThreads);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalSchedulersEventLoopsScheduler_FixedSchedulerPool)

#endif

#if !defined (RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_) && (INCLUDE_ALL_RxInternalSchedulersEventLoopsScheduler || defined(INCLUDE_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker))
#define RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_

#define RESTRICT_RxScheduler 1
#define INCLUDE_RxScheduler_Worker 1
#include "RxScheduler.h"

@class JavaUtilConcurrentTimeUnit;
@class RxInternalSchedulersEventLoopsScheduler_PoolWorker;
@protocol RxFunctionsAction0;
@protocol RxSubscription;

@interface RxInternalSchedulersEventLoopsScheduler_EventLoopWorker : RxScheduler_Worker

#pragma mark Public

- (jboolean)isUnsubscribed;

- (id<RxSubscription>)scheduleWithRxFunctionsAction0:(id<RxFunctionsAction0>)action;

- (id<RxSubscription>)scheduleWithRxFunctionsAction0:(id<RxFunctionsAction0>)action
                                            withLong:(jlong)delayTime
                      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

- (void)unsubscribe;

#pragma mark Package-Private

- (instancetype)initWithRxInternalSchedulersEventLoopsScheduler_PoolWorker:(RxInternalSchedulersEventLoopsScheduler_PoolWorker *)poolWorker;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker)

FOUNDATION_EXPORT void RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_initWithRxInternalSchedulersEventLoopsScheduler_PoolWorker_(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *self, RxInternalSchedulersEventLoopsScheduler_PoolWorker *poolWorker);

FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *new_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_initWithRxInternalSchedulersEventLoopsScheduler_PoolWorker_(RxInternalSchedulersEventLoopsScheduler_PoolWorker *poolWorker) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler_EventLoopWorker *create_RxInternalSchedulersEventLoopsScheduler_EventLoopWorker_initWithRxInternalSchedulersEventLoopsScheduler_PoolWorker_(RxInternalSchedulersEventLoopsScheduler_PoolWorker *poolWorker);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalSchedulersEventLoopsScheduler_EventLoopWorker)

#endif

#if !defined (RxInternalSchedulersEventLoopsScheduler_PoolWorker_) && (INCLUDE_ALL_RxInternalSchedulersEventLoopsScheduler || defined(INCLUDE_RxInternalSchedulersEventLoopsScheduler_PoolWorker))
#define RxInternalSchedulersEventLoopsScheduler_PoolWorker_

#define RESTRICT_RxInternalSchedulersNewThreadWorker 1
#define INCLUDE_RxInternalSchedulersNewThreadWorker 1
#include "RxInternalSchedulersNewThreadWorker.h"

@protocol JavaUtilConcurrentThreadFactory;

@interface RxInternalSchedulersEventLoopsScheduler_PoolWorker : RxInternalSchedulersNewThreadWorker

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentThreadFactory:(id<JavaUtilConcurrentThreadFactory>)threadFactory;

@end

J2OBJC_EMPTY_STATIC_INIT(RxInternalSchedulersEventLoopsScheduler_PoolWorker)

FOUNDATION_EXPORT void RxInternalSchedulersEventLoopsScheduler_PoolWorker_initWithJavaUtilConcurrentThreadFactory_(RxInternalSchedulersEventLoopsScheduler_PoolWorker *self, id<JavaUtilConcurrentThreadFactory> threadFactory);

FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler_PoolWorker *new_RxInternalSchedulersEventLoopsScheduler_PoolWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT RxInternalSchedulersEventLoopsScheduler_PoolWorker *create_RxInternalSchedulersEventLoopsScheduler_PoolWorker_initWithJavaUtilConcurrentThreadFactory_(id<JavaUtilConcurrentThreadFactory> threadFactory);

J2OBJC_TYPE_LITERAL_HEADER(RxInternalSchedulersEventLoopsScheduler_PoolWorker)

#endif

#pragma pop_macro("INCLUDE_ALL_RxInternalSchedulersEventLoopsScheduler")
