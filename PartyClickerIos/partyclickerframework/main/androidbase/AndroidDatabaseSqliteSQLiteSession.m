//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/kgalligan/devel-doppl/core-doppl/androidbase/src/main/java/android/database/sqlite/SQLiteSession.java
//

#include "AndroidDatabaseCursorWindow.h"
#include "AndroidDatabaseDatabaseUtils.h"
#include "AndroidDatabaseSqliteSQLiteConnection.h"
#include "AndroidDatabaseSqliteSQLiteConnectionPool.h"
#include "AndroidDatabaseSqliteSQLiteSession.h"
#include "AndroidDatabaseSqliteSQLiteStatementInfo.h"
#include "AndroidDatabaseSqliteSQLiteTransactionListener.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/InterruptedException.h"
#include "java/lang/RuntimeException.h"
#include "java/lang/Thread.h"

@class AndroidDatabaseSqliteSQLiteSession_Transaction;

@interface AndroidDatabaseSqliteSQLiteSession () {
 @public
  AndroidDatabaseSqliteSQLiteConnectionPool *mConnectionPool_;
  AndroidDatabaseSqliteSQLiteConnection *mConnection_;
  jint mConnectionFlags_;
  jint mConnectionUseCount_;
  AndroidDatabaseSqliteSQLiteSession_Transaction *mTransactionPool_;
  AndroidDatabaseSqliteSQLiteSession_Transaction *mTransactionStack_;
}

- (void)beginTransactionUncheckedWithInt:(jint)transactionMode
withAndroidDatabaseSqliteSQLiteTransactionListener:(id<AndroidDatabaseSqliteSQLiteTransactionListener>)transactionListener
                                 withInt:(jint)connectionFlags;

- (void)endTransactionUncheckedWithBoolean:(jboolean)yielding;

- (jboolean)yieldTransactionUncheckedWithLong:(jlong)sleepAfterYieldDelayMillis;

- (jboolean)executeSpecialWithNSString:(NSString *)sql
                     withNSObjectArray:(IOSObjectArray *)bindArgs
                               withInt:(jint)connectionFlags;

- (void)acquireConnectionWithNSString:(NSString *)sql
                              withInt:(jint)connectionFlags;

- (void)releaseConnection;

- (void)throwIfNoTransaction;

- (void)throwIfTransactionMarkedSuccessful;

- (void)throwIfNestedTransaction;

- (AndroidDatabaseSqliteSQLiteSession_Transaction *)obtainTransactionWithInt:(jint)mode
                          withAndroidDatabaseSqliteSQLiteTransactionListener:(id<AndroidDatabaseSqliteSQLiteTransactionListener>)listener;

- (void)recycleTransactionWithAndroidDatabaseSqliteSQLiteSession_Transaction:(AndroidDatabaseSqliteSQLiteSession_Transaction *)transaction;

@end

J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteSession, mConnectionPool_, AndroidDatabaseSqliteSQLiteConnectionPool *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteSession, mConnection_, AndroidDatabaseSqliteSQLiteConnection *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteSession, mTransactionPool_, AndroidDatabaseSqliteSQLiteSession_Transaction *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteSession, mTransactionStack_, AndroidDatabaseSqliteSQLiteSession_Transaction *)

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteSession_beginTransactionUncheckedWithInt_withAndroidDatabaseSqliteSQLiteTransactionListener_withInt_(AndroidDatabaseSqliteSQLiteSession *self, jint transactionMode, id<AndroidDatabaseSqliteSQLiteTransactionListener> transactionListener, jint connectionFlags);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteSession_endTransactionUncheckedWithBoolean_(AndroidDatabaseSqliteSQLiteSession *self, jboolean yielding);

__attribute__((unused)) static jboolean AndroidDatabaseSqliteSQLiteSession_yieldTransactionUncheckedWithLong_(AndroidDatabaseSqliteSQLiteSession *self, jlong sleepAfterYieldDelayMillis);

__attribute__((unused)) static jboolean AndroidDatabaseSqliteSQLiteSession_executeSpecialWithNSString_withNSObjectArray_withInt_(AndroidDatabaseSqliteSQLiteSession *self, NSString *sql, IOSObjectArray *bindArgs, jint connectionFlags);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteSession_acquireConnectionWithNSString_withInt_(AndroidDatabaseSqliteSQLiteSession *self, NSString *sql, jint connectionFlags);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteSession_releaseConnection(AndroidDatabaseSqliteSQLiteSession *self);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteSession_throwIfNoTransaction(AndroidDatabaseSqliteSQLiteSession *self);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteSession_throwIfTransactionMarkedSuccessful(AndroidDatabaseSqliteSQLiteSession *self);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteSession_throwIfNestedTransaction(AndroidDatabaseSqliteSQLiteSession *self);

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteSession_Transaction *AndroidDatabaseSqliteSQLiteSession_obtainTransactionWithInt_withAndroidDatabaseSqliteSQLiteTransactionListener_(AndroidDatabaseSqliteSQLiteSession *self, jint mode, id<AndroidDatabaseSqliteSQLiteTransactionListener> listener);

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteSession_recycleTransactionWithAndroidDatabaseSqliteSQLiteSession_Transaction_(AndroidDatabaseSqliteSQLiteSession *self, AndroidDatabaseSqliteSQLiteSession_Transaction *transaction);

@interface AndroidDatabaseSqliteSQLiteSession_Transaction : NSObject {
 @public
  AndroidDatabaseSqliteSQLiteSession_Transaction *mParent_;
  jint mMode_;
  id<AndroidDatabaseSqliteSQLiteTransactionListener> mListener_;
  jboolean mMarkedSuccessful_;
  jboolean mChildFailed_;
}

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidDatabaseSqliteSQLiteSession_Transaction)

J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteSession_Transaction, mParent_, AndroidDatabaseSqliteSQLiteSession_Transaction *)
J2OBJC_FIELD_SETTER(AndroidDatabaseSqliteSQLiteSession_Transaction, mListener_, id<AndroidDatabaseSqliteSQLiteTransactionListener>)

__attribute__((unused)) static void AndroidDatabaseSqliteSQLiteSession_Transaction_init(AndroidDatabaseSqliteSQLiteSession_Transaction *self);

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteSession_Transaction *new_AndroidDatabaseSqliteSQLiteSession_Transaction_init() NS_RETURNS_RETAINED;

__attribute__((unused)) static AndroidDatabaseSqliteSQLiteSession_Transaction *create_AndroidDatabaseSqliteSQLiteSession_Transaction_init();

J2OBJC_TYPE_LITERAL_HEADER(AndroidDatabaseSqliteSQLiteSession_Transaction)

@implementation AndroidDatabaseSqliteSQLiteSession

- (instancetype)initWithAndroidDatabaseSqliteSQLiteConnectionPool:(AndroidDatabaseSqliteSQLiteConnectionPool *)connectionPool {
  AndroidDatabaseSqliteSQLiteSession_initWithAndroidDatabaseSqliteSQLiteConnectionPool_(self, connectionPool);
  return self;
}

- (jboolean)hasTransaction {
  return mTransactionStack_ != nil;
}

- (jboolean)hasNestedTransaction {
  return mTransactionStack_ != nil && mTransactionStack_->mParent_ != nil;
}

- (jboolean)hasConnection {
  return mConnection_ != nil;
}

- (void)beginTransactionWithInt:(jint)transactionMode
withAndroidDatabaseSqliteSQLiteTransactionListener:(id<AndroidDatabaseSqliteSQLiteTransactionListener>)transactionListener
                        withInt:(jint)connectionFlags {
  AndroidDatabaseSqliteSQLiteSession_throwIfTransactionMarkedSuccessful(self);
  AndroidDatabaseSqliteSQLiteSession_beginTransactionUncheckedWithInt_withAndroidDatabaseSqliteSQLiteTransactionListener_withInt_(self, transactionMode, transactionListener, connectionFlags);
}

- (void)beginTransactionUncheckedWithInt:(jint)transactionMode
withAndroidDatabaseSqliteSQLiteTransactionListener:(id<AndroidDatabaseSqliteSQLiteTransactionListener>)transactionListener
                                 withInt:(jint)connectionFlags {
  AndroidDatabaseSqliteSQLiteSession_beginTransactionUncheckedWithInt_withAndroidDatabaseSqliteSQLiteTransactionListener_withInt_(self, transactionMode, transactionListener, connectionFlags);
}

- (void)setTransactionSuccessful {
  AndroidDatabaseSqliteSQLiteSession_throwIfNoTransaction(self);
  AndroidDatabaseSqliteSQLiteSession_throwIfTransactionMarkedSuccessful(self);
  ((AndroidDatabaseSqliteSQLiteSession_Transaction *) nil_chk(mTransactionStack_))->mMarkedSuccessful_ = true;
}

- (void)endTransaction {
  AndroidDatabaseSqliteSQLiteSession_throwIfNoTransaction(self);
  JreAssert((mConnection_ != nil), (@"android/database/sqlite/SQLiteSession.java:383 condition failed: assert mConnection != null;"));
  AndroidDatabaseSqliteSQLiteSession_endTransactionUncheckedWithBoolean_(self, false);
}

- (void)endTransactionUncheckedWithBoolean:(jboolean)yielding {
  AndroidDatabaseSqliteSQLiteSession_endTransactionUncheckedWithBoolean_(self, yielding);
}

- (jboolean)yieldTransactionWithLong:(jlong)sleepAfterYieldDelayMillis
                         withBoolean:(jboolean)throwIfUnsafe {
  if (throwIfUnsafe) {
    AndroidDatabaseSqliteSQLiteSession_throwIfNoTransaction(self);
    AndroidDatabaseSqliteSQLiteSession_throwIfTransactionMarkedSuccessful(self);
    AndroidDatabaseSqliteSQLiteSession_throwIfNestedTransaction(self);
  }
  else {
    if (mTransactionStack_ == nil || mTransactionStack_->mMarkedSuccessful_ || mTransactionStack_->mParent_ != nil) {
      return false;
    }
  }
  JreAssert((mConnection_ != nil), (@"android/database/sqlite/SQLiteSession.java:491 condition failed: assert mConnection != null;"));
  if (((AndroidDatabaseSqliteSQLiteSession_Transaction *) nil_chk(mTransactionStack_))->mChildFailed_) {
    return false;
  }
  return AndroidDatabaseSqliteSQLiteSession_yieldTransactionUncheckedWithLong_(self, sleepAfterYieldDelayMillis);
}

- (jboolean)yieldTransactionUncheckedWithLong:(jlong)sleepAfterYieldDelayMillis {
  return AndroidDatabaseSqliteSQLiteSession_yieldTransactionUncheckedWithLong_(self, sleepAfterYieldDelayMillis);
}

- (void)prepareWithNSString:(NSString *)sql
                    withInt:(jint)connectionFlags
withAndroidDatabaseSqliteSQLiteStatementInfo:(AndroidDatabaseSqliteSQLiteStatementInfo *)outStatementInfo {
  if (sql == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"sql must not be null.");
  }
  AndroidDatabaseSqliteSQLiteSession_acquireConnectionWithNSString_withInt_(self, sql, connectionFlags);
  @try {
    [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(mConnection_)) prepareWithNSString:sql withAndroidDatabaseSqliteSQLiteStatementInfo:outStatementInfo];
  }
  @finally {
    AndroidDatabaseSqliteSQLiteSession_releaseConnection(self);
  }
}

- (void)executeWithNSString:(NSString *)sql
          withNSObjectArray:(IOSObjectArray *)bindArgs
                    withInt:(jint)connectionFlags {
  if (sql == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"sql must not be null.");
  }
  if (AndroidDatabaseSqliteSQLiteSession_executeSpecialWithNSString_withNSObjectArray_withInt_(self, sql, bindArgs, connectionFlags)) {
    return;
  }
  AndroidDatabaseSqliteSQLiteSession_acquireConnectionWithNSString_withInt_(self, sql, connectionFlags);
  @try {
    [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(mConnection_)) executeWithNSString:sql withNSObjectArray:bindArgs];
  }
  @finally {
    AndroidDatabaseSqliteSQLiteSession_releaseConnection(self);
  }
}

- (jlong)executeForLongWithNSString:(NSString *)sql
                  withNSObjectArray:(IOSObjectArray *)bindArgs
                            withInt:(jint)connectionFlags {
  if (sql == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"sql must not be null.");
  }
  if (AndroidDatabaseSqliteSQLiteSession_executeSpecialWithNSString_withNSObjectArray_withInt_(self, sql, bindArgs, connectionFlags)) {
    return 0;
  }
  AndroidDatabaseSqliteSQLiteSession_acquireConnectionWithNSString_withInt_(self, sql, connectionFlags);
  @try {
    return [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(mConnection_)) executeForLongWithNSString:sql withNSObjectArray:bindArgs];
  }
  @finally {
    AndroidDatabaseSqliteSQLiteSession_releaseConnection(self);
  }
}

- (NSString *)executeForStringWithNSString:(NSString *)sql
                         withNSObjectArray:(IOSObjectArray *)bindArgs
                                   withInt:(jint)connectionFlags {
  if (sql == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"sql must not be null.");
  }
  if (AndroidDatabaseSqliteSQLiteSession_executeSpecialWithNSString_withNSObjectArray_withInt_(self, sql, bindArgs, connectionFlags)) {
    return nil;
  }
  AndroidDatabaseSqliteSQLiteSession_acquireConnectionWithNSString_withInt_(self, sql, connectionFlags);
  @try {
    return [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(mConnection_)) executeForStringWithNSString:sql withNSObjectArray:bindArgs];
  }
  @finally {
    AndroidDatabaseSqliteSQLiteSession_releaseConnection(self);
  }
}

- (jint)executeForChangedRowCountWithNSString:(NSString *)sql
                            withNSObjectArray:(IOSObjectArray *)bindArgs
                                      withInt:(jint)connectionFlags {
  if (sql == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"sql must not be null.");
  }
  if (AndroidDatabaseSqliteSQLiteSession_executeSpecialWithNSString_withNSObjectArray_withInt_(self, sql, bindArgs, connectionFlags)) {
    return 0;
  }
  AndroidDatabaseSqliteSQLiteSession_acquireConnectionWithNSString_withInt_(self, sql, connectionFlags);
  @try {
    return [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(mConnection_)) executeForChangedRowCountWithNSString:sql withNSObjectArray:bindArgs];
  }
  @finally {
    AndroidDatabaseSqliteSQLiteSession_releaseConnection(self);
  }
}

- (jlong)executeForLastInsertedRowIdWithNSString:(NSString *)sql
                               withNSObjectArray:(IOSObjectArray *)bindArgs
                                         withInt:(jint)connectionFlags {
  if (sql == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"sql must not be null.");
  }
  if (AndroidDatabaseSqliteSQLiteSession_executeSpecialWithNSString_withNSObjectArray_withInt_(self, sql, bindArgs, connectionFlags)) {
    return 0;
  }
  AndroidDatabaseSqliteSQLiteSession_acquireConnectionWithNSString_withInt_(self, sql, connectionFlags);
  @try {
    return [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(mConnection_)) executeForLastInsertedRowIdWithNSString:sql withNSObjectArray:bindArgs];
  }
  @finally {
    AndroidDatabaseSqliteSQLiteSession_releaseConnection(self);
  }
}

- (jint)executeForCursorWindowWithNSString:(NSString *)sql
                         withNSObjectArray:(IOSObjectArray *)bindArgs
           withAndroidDatabaseCursorWindow:(AndroidDatabaseCursorWindow *)window
                                   withInt:(jint)startPos
                                   withInt:(jint)requiredPos
                               withBoolean:(jboolean)countAllRows
                                   withInt:(jint)connectionFlags {
  if (sql == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"sql must not be null.");
  }
  if (window == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"window must not be null.");
  }
  if (AndroidDatabaseSqliteSQLiteSession_executeSpecialWithNSString_withNSObjectArray_withInt_(self, sql, bindArgs, connectionFlags)) {
    [window clear];
    return 0;
  }
  AndroidDatabaseSqliteSQLiteSession_acquireConnectionWithNSString_withInt_(self, sql, connectionFlags);
  @try {
    return [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(mConnection_)) executeForCursorWindowWithNSString:sql withNSObjectArray:bindArgs withAndroidDatabaseCursorWindow:window withInt:startPos withInt:requiredPos withBoolean:countAllRows];
  }
  @finally {
    AndroidDatabaseSqliteSQLiteSession_releaseConnection(self);
  }
}

- (jboolean)executeSpecialWithNSString:(NSString *)sql
                     withNSObjectArray:(IOSObjectArray *)bindArgs
                               withInt:(jint)connectionFlags {
  return AndroidDatabaseSqliteSQLiteSession_executeSpecialWithNSString_withNSObjectArray_withInt_(self, sql, bindArgs, connectionFlags);
}

- (void)acquireConnectionWithNSString:(NSString *)sql
                              withInt:(jint)connectionFlags {
  AndroidDatabaseSqliteSQLiteSession_acquireConnectionWithNSString_withInt_(self, sql, connectionFlags);
}

- (void)releaseConnection {
  AndroidDatabaseSqliteSQLiteSession_releaseConnection(self);
}

- (void)throwIfNoTransaction {
  AndroidDatabaseSqliteSQLiteSession_throwIfNoTransaction(self);
}

- (void)throwIfTransactionMarkedSuccessful {
  AndroidDatabaseSqliteSQLiteSession_throwIfTransactionMarkedSuccessful(self);
}

- (void)throwIfNestedTransaction {
  AndroidDatabaseSqliteSQLiteSession_throwIfNestedTransaction(self);
}

- (AndroidDatabaseSqliteSQLiteSession_Transaction *)obtainTransactionWithInt:(jint)mode
                          withAndroidDatabaseSqliteSQLiteTransactionListener:(id<AndroidDatabaseSqliteSQLiteTransactionListener>)listener {
  return AndroidDatabaseSqliteSQLiteSession_obtainTransactionWithInt_withAndroidDatabaseSqliteSQLiteTransactionListener_(self, mode, listener);
}

- (void)recycleTransactionWithAndroidDatabaseSqliteSQLiteSession_Transaction:(AndroidDatabaseSqliteSQLiteSession_Transaction *)transaction {
  AndroidDatabaseSqliteSQLiteSession_recycleTransactionWithAndroidDatabaseSqliteSQLiteSession_Transaction_(self, transaction);
}

- (void)dealloc {
  RELEASE_(mConnectionPool_);
  RELEASE_(mConnection_);
  RELEASE_(mTransactionPool_);
  RELEASE_(mTransactionStack_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 3, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 4, 5, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 8, 9, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 11, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 12, 13, -1, -1, -1, -1 },
    { NULL, "J", 0x1, 14, 13, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 15, 13, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 16, 13, -1, -1, -1, -1 },
    { NULL, "J", 0x1, 17, 13, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 18, 19, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 20, 13, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 21, 22, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "LAndroidDatabaseSqliteSQLiteSession_Transaction;", 0x2, 23, 24, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 25, 26, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithAndroidDatabaseSqliteSQLiteConnectionPool:);
  methods[1].selector = @selector(hasTransaction);
  methods[2].selector = @selector(hasNestedTransaction);
  methods[3].selector = @selector(hasConnection);
  methods[4].selector = @selector(beginTransactionWithInt:withAndroidDatabaseSqliteSQLiteTransactionListener:withInt:);
  methods[5].selector = @selector(beginTransactionUncheckedWithInt:withAndroidDatabaseSqliteSQLiteTransactionListener:withInt:);
  methods[6].selector = @selector(setTransactionSuccessful);
  methods[7].selector = @selector(endTransaction);
  methods[8].selector = @selector(endTransactionUncheckedWithBoolean:);
  methods[9].selector = @selector(yieldTransactionWithLong:withBoolean:);
  methods[10].selector = @selector(yieldTransactionUncheckedWithLong:);
  methods[11].selector = @selector(prepareWithNSString:withInt:withAndroidDatabaseSqliteSQLiteStatementInfo:);
  methods[12].selector = @selector(executeWithNSString:withNSObjectArray:withInt:);
  methods[13].selector = @selector(executeForLongWithNSString:withNSObjectArray:withInt:);
  methods[14].selector = @selector(executeForStringWithNSString:withNSObjectArray:withInt:);
  methods[15].selector = @selector(executeForChangedRowCountWithNSString:withNSObjectArray:withInt:);
  methods[16].selector = @selector(executeForLastInsertedRowIdWithNSString:withNSObjectArray:withInt:);
  methods[17].selector = @selector(executeForCursorWindowWithNSString:withNSObjectArray:withAndroidDatabaseCursorWindow:withInt:withInt:withBoolean:withInt:);
  methods[18].selector = @selector(executeSpecialWithNSString:withNSObjectArray:withInt:);
  methods[19].selector = @selector(acquireConnectionWithNSString:withInt:);
  methods[20].selector = @selector(releaseConnection);
  methods[21].selector = @selector(throwIfNoTransaction);
  methods[22].selector = @selector(throwIfTransactionMarkedSuccessful);
  methods[23].selector = @selector(throwIfNestedTransaction);
  methods[24].selector = @selector(obtainTransactionWithInt:withAndroidDatabaseSqliteSQLiteTransactionListener:);
  methods[25].selector = @selector(recycleTransactionWithAndroidDatabaseSqliteSQLiteSession_Transaction:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "mConnectionPool_", "LAndroidDatabaseSqliteSQLiteConnectionPool;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "mConnection_", "LAndroidDatabaseSqliteSQLiteConnection;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mConnectionFlags_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mConnectionUseCount_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTransactionPool_", "LAndroidDatabaseSqliteSQLiteSession_Transaction;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "mTransactionStack_", "LAndroidDatabaseSqliteSQLiteSession_Transaction;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "TRANSACTION_MODE_DEFERRED", "I", .constantValue.asInt = AndroidDatabaseSqliteSQLiteSession_TRANSACTION_MODE_DEFERRED, 0x19, -1, -1, -1, -1 },
    { "TRANSACTION_MODE_IMMEDIATE", "I", .constantValue.asInt = AndroidDatabaseSqliteSQLiteSession_TRANSACTION_MODE_IMMEDIATE, 0x19, -1, -1, -1, -1 },
    { "TRANSACTION_MODE_EXCLUSIVE", "I", .constantValue.asInt = AndroidDatabaseSqliteSQLiteSession_TRANSACTION_MODE_EXCLUSIVE, 0x19, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LAndroidDatabaseSqliteSQLiteConnectionPool;", "beginTransaction", "ILAndroidDatabaseSqliteSQLiteTransactionListener;I", "beginTransactionUnchecked", "endTransactionUnchecked", "Z", "yieldTransaction", "JZ", "yieldTransactionUnchecked", "J", "prepare", "LNSString;ILAndroidDatabaseSqliteSQLiteStatementInfo;", "execute", "LNSString;[LNSObject;I", "executeForLong", "executeForString", "executeForChangedRowCount", "executeForLastInsertedRowId", "executeForCursorWindow", "LNSString;[LNSObject;LAndroidDatabaseCursorWindow;IIZI", "executeSpecial", "acquireConnection", "LNSString;I", "obtainTransaction", "ILAndroidDatabaseSqliteSQLiteTransactionListener;", "recycleTransaction", "LAndroidDatabaseSqliteSQLiteSession_Transaction;" };
  static const J2ObjcClassInfo _AndroidDatabaseSqliteSQLiteSession = { "SQLiteSession", "android.database.sqlite", ptrTable, methods, fields, 7, 0x11, 26, 9, -1, 26, -1, -1, -1 };
  return &_AndroidDatabaseSqliteSQLiteSession;
}

@end

void AndroidDatabaseSqliteSQLiteSession_initWithAndroidDatabaseSqliteSQLiteConnectionPool_(AndroidDatabaseSqliteSQLiteSession *self, AndroidDatabaseSqliteSQLiteConnectionPool *connectionPool) {
  NSObject_init(self);
  if (connectionPool == nil) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"connectionPool must not be null");
  }
  JreStrongAssign(&self->mConnectionPool_, connectionPool);
}

AndroidDatabaseSqliteSQLiteSession *new_AndroidDatabaseSqliteSQLiteSession_initWithAndroidDatabaseSqliteSQLiteConnectionPool_(AndroidDatabaseSqliteSQLiteConnectionPool *connectionPool) {
  J2OBJC_NEW_IMPL(AndroidDatabaseSqliteSQLiteSession, initWithAndroidDatabaseSqliteSQLiteConnectionPool_, connectionPool)
}

AndroidDatabaseSqliteSQLiteSession *create_AndroidDatabaseSqliteSQLiteSession_initWithAndroidDatabaseSqliteSQLiteConnectionPool_(AndroidDatabaseSqliteSQLiteConnectionPool *connectionPool) {
  J2OBJC_CREATE_IMPL(AndroidDatabaseSqliteSQLiteSession, initWithAndroidDatabaseSqliteSQLiteConnectionPool_, connectionPool)
}

void AndroidDatabaseSqliteSQLiteSession_beginTransactionUncheckedWithInt_withAndroidDatabaseSqliteSQLiteTransactionListener_withInt_(AndroidDatabaseSqliteSQLiteSession *self, jint transactionMode, id<AndroidDatabaseSqliteSQLiteTransactionListener> transactionListener, jint connectionFlags) {
  if (self->mTransactionStack_ == nil) {
    AndroidDatabaseSqliteSQLiteSession_acquireConnectionWithNSString_withInt_(self, nil, connectionFlags);
  }
  @try {
    if (self->mTransactionStack_ == nil) {
      switch (transactionMode) {
        case AndroidDatabaseSqliteSQLiteSession_TRANSACTION_MODE_IMMEDIATE:
        [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(self->mConnection_)) executeWithNSString:@"BEGIN IMMEDIATE;" withNSObjectArray:nil];
        break;
        case AndroidDatabaseSqliteSQLiteSession_TRANSACTION_MODE_EXCLUSIVE:
        [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(self->mConnection_)) executeWithNSString:@"BEGIN EXCLUSIVE;" withNSObjectArray:nil];
        break;
        default:
        [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(self->mConnection_)) executeWithNSString:@"BEGIN;" withNSObjectArray:nil];
        break;
      }
    }
    if (transactionListener != nil) {
      @try {
        [transactionListener onBegin];
      }
      @catch (JavaLangRuntimeException *ex) {
        if (self->mTransactionStack_ == nil) {
          [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(self->mConnection_)) executeWithNSString:@"ROLLBACK;" withNSObjectArray:nil];
        }
        @throw ex;
      }
    }
    AndroidDatabaseSqliteSQLiteSession_Transaction *transaction = AndroidDatabaseSqliteSQLiteSession_obtainTransactionWithInt_withAndroidDatabaseSqliteSQLiteTransactionListener_(self, transactionMode, transactionListener);
    JreStrongAssign(&((AndroidDatabaseSqliteSQLiteSession_Transaction *) nil_chk(transaction))->mParent_, self->mTransactionStack_);
    JreStrongAssign(&self->mTransactionStack_, transaction);
  }
  @finally {
    if (self->mTransactionStack_ == nil) {
      AndroidDatabaseSqliteSQLiteSession_releaseConnection(self);
    }
  }
}

void AndroidDatabaseSqliteSQLiteSession_endTransactionUncheckedWithBoolean_(AndroidDatabaseSqliteSQLiteSession *self, jboolean yielding) {
  AndroidDatabaseSqliteSQLiteSession_Transaction *top = self->mTransactionStack_;
  jboolean successful = (((AndroidDatabaseSqliteSQLiteSession_Transaction *) nil_chk(top))->mMarkedSuccessful_ || yielding) && !top->mChildFailed_;
  JavaLangRuntimeException *listenerException = nil;
  id<AndroidDatabaseSqliteSQLiteTransactionListener> listener = top->mListener_;
  if (listener != nil) {
    @try {
      if (successful) {
        [listener onCommit];
      }
      else {
        [listener onRollback];
      }
    }
    @catch (JavaLangRuntimeException *ex) {
      listenerException = ex;
      successful = false;
    }
  }
  JreStrongAssign(&self->mTransactionStack_, top->mParent_);
  AndroidDatabaseSqliteSQLiteSession_recycleTransactionWithAndroidDatabaseSqliteSQLiteSession_Transaction_(self, top);
  if (self->mTransactionStack_ != nil) {
    if (!successful) {
      self->mTransactionStack_->mChildFailed_ = true;
    }
  }
  else {
    @try {
      if (successful) {
        [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(self->mConnection_)) executeWithNSString:@"COMMIT;" withNSObjectArray:nil];
      }
      else {
        [((AndroidDatabaseSqliteSQLiteConnection *) nil_chk(self->mConnection_)) executeWithNSString:@"ROLLBACK;" withNSObjectArray:nil];
      }
    }
    @finally {
      AndroidDatabaseSqliteSQLiteSession_releaseConnection(self);
    }
  }
  if (listenerException != nil) {
    @throw listenerException;
  }
}

jboolean AndroidDatabaseSqliteSQLiteSession_yieldTransactionUncheckedWithLong_(AndroidDatabaseSqliteSQLiteSession *self, jlong sleepAfterYieldDelayMillis) {
  if (![((AndroidDatabaseSqliteSQLiteConnectionPool *) nil_chk(self->mConnectionPool_)) shouldYieldConnectionWithAndroidDatabaseSqliteSQLiteConnection:self->mConnection_ withInt:self->mConnectionFlags_]) {
    return false;
  }
  jint transactionMode = ((AndroidDatabaseSqliteSQLiteSession_Transaction *) nil_chk(self->mTransactionStack_))->mMode_;
  id<AndroidDatabaseSqliteSQLiteTransactionListener> listener = self->mTransactionStack_->mListener_;
  jint connectionFlags = self->mConnectionFlags_;
  AndroidDatabaseSqliteSQLiteSession_endTransactionUncheckedWithBoolean_(self, true);
  if (sleepAfterYieldDelayMillis > 0) {
    @try {
      JavaLangThread_sleepWithLong_(sleepAfterYieldDelayMillis);
    }
    @catch (JavaLangInterruptedException *ex) {
    }
  }
  AndroidDatabaseSqliteSQLiteSession_beginTransactionUncheckedWithInt_withAndroidDatabaseSqliteSQLiteTransactionListener_withInt_(self, transactionMode, listener, connectionFlags);
  return true;
}

jboolean AndroidDatabaseSqliteSQLiteSession_executeSpecialWithNSString_withNSObjectArray_withInt_(AndroidDatabaseSqliteSQLiteSession *self, NSString *sql, IOSObjectArray *bindArgs, jint connectionFlags) {
  jint type = AndroidDatabaseDatabaseUtils_getSqlStatementTypeWithNSString_(sql);
  switch (type) {
    case AndroidDatabaseDatabaseUtils_STATEMENT_BEGIN:
    [self beginTransactionWithInt:AndroidDatabaseSqliteSQLiteSession_TRANSACTION_MODE_EXCLUSIVE withAndroidDatabaseSqliteSQLiteTransactionListener:nil withInt:connectionFlags];
    return true;
    case AndroidDatabaseDatabaseUtils_STATEMENT_COMMIT:
    [self setTransactionSuccessful];
    [self endTransaction];
    return true;
    case AndroidDatabaseDatabaseUtils_STATEMENT_ABORT:
    [self endTransaction];
    return true;
  }
  return false;
}

void AndroidDatabaseSqliteSQLiteSession_acquireConnectionWithNSString_withInt_(AndroidDatabaseSqliteSQLiteSession *self, NSString *sql, jint connectionFlags) {
  if (self->mConnection_ == nil) {
    JreAssert((self->mConnectionUseCount_ == 0), (@"android/database/sqlite/SQLiteSession.java:793 condition failed: assert mConnectionUseCount == 0;"));
    JreStrongAssign(&self->mConnection_, [((AndroidDatabaseSqliteSQLiteConnectionPool *) nil_chk(self->mConnectionPool_)) acquireConnectionWithNSString:sql withInt:connectionFlags]);
    self->mConnectionFlags_ = connectionFlags;
  }
  self->mConnectionUseCount_ += 1;
}

void AndroidDatabaseSqliteSQLiteSession_releaseConnection(AndroidDatabaseSqliteSQLiteSession *self) {
  JreAssert((self->mConnection_ != nil), (@"android/database/sqlite/SQLiteSession.java:801 condition failed: assert mConnection != null;"));
  JreAssert((self->mConnectionUseCount_ > 0), (@"android/database/sqlite/SQLiteSession.java:802 condition failed: assert mConnectionUseCount > 0;"));
  if (--self->mConnectionUseCount_ == 0) {
    @try {
      [((AndroidDatabaseSqliteSQLiteConnectionPool *) nil_chk(self->mConnectionPool_)) releaseConnectionWithAndroidDatabaseSqliteSQLiteConnection:self->mConnection_];
    }
    @finally {
      JreStrongAssign(&self->mConnection_, nil);
    }
  }
}

void AndroidDatabaseSqliteSQLiteSession_throwIfNoTransaction(AndroidDatabaseSqliteSQLiteSession *self) {
  if (self->mTransactionStack_ == nil) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(@"Cannot perform this operation because there is no current transaction.");
  }
}

void AndroidDatabaseSqliteSQLiteSession_throwIfTransactionMarkedSuccessful(AndroidDatabaseSqliteSQLiteSession *self) {
  if (self->mTransactionStack_ != nil && self->mTransactionStack_->mMarkedSuccessful_) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(@"Cannot perform this operation because the transaction has already been marked successful.  The only thing you can do now is call endTransaction().");
  }
}

void AndroidDatabaseSqliteSQLiteSession_throwIfNestedTransaction(AndroidDatabaseSqliteSQLiteSession *self) {
  if ([self hasNestedTransaction]) {
    @throw create_JavaLangIllegalStateException_initWithNSString_(@"Cannot perform this operation because a nested transaction is in progress.");
  }
}

AndroidDatabaseSqliteSQLiteSession_Transaction *AndroidDatabaseSqliteSQLiteSession_obtainTransactionWithInt_withAndroidDatabaseSqliteSQLiteTransactionListener_(AndroidDatabaseSqliteSQLiteSession *self, jint mode, id<AndroidDatabaseSqliteSQLiteTransactionListener> listener) {
  AndroidDatabaseSqliteSQLiteSession_Transaction *transaction = self->mTransactionPool_;
  if (transaction != nil) {
    JreStrongAssign(&self->mTransactionPool_, transaction->mParent_);
    JreStrongAssign(&transaction->mParent_, nil);
    transaction->mMarkedSuccessful_ = false;
    transaction->mChildFailed_ = false;
  }
  else {
    transaction = create_AndroidDatabaseSqliteSQLiteSession_Transaction_init();
  }
  transaction->mMode_ = mode;
  JreStrongAssign(&transaction->mListener_, listener);
  return transaction;
}

void AndroidDatabaseSqliteSQLiteSession_recycleTransactionWithAndroidDatabaseSqliteSQLiteSession_Transaction_(AndroidDatabaseSqliteSQLiteSession *self, AndroidDatabaseSqliteSQLiteSession_Transaction *transaction) {
  JreStrongAssign(&((AndroidDatabaseSqliteSQLiteSession_Transaction *) nil_chk(transaction))->mParent_, self->mTransactionPool_);
  JreStrongAssign(&transaction->mListener_, nil);
  JreStrongAssign(&self->mTransactionPool_, transaction);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidDatabaseSqliteSQLiteSession)

@implementation AndroidDatabaseSqliteSQLiteSession_Transaction

J2OBJC_IGNORE_DESIGNATED_BEGIN
- (instancetype)init {
  AndroidDatabaseSqliteSQLiteSession_Transaction_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END

- (void)dealloc {
  RELEASE_(mParent_);
  RELEASE_(mListener_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(init);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "mParent_", "LAndroidDatabaseSqliteSQLiteSession_Transaction;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mMode_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mListener_", "LAndroidDatabaseSqliteSQLiteTransactionListener;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mMarkedSuccessful_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "mChildFailed_", "Z", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LAndroidDatabaseSqliteSQLiteSession;" };
  static const J2ObjcClassInfo _AndroidDatabaseSqliteSQLiteSession_Transaction = { "Transaction", "android.database.sqlite", ptrTable, methods, fields, 7, 0x1a, 1, 5, 0, -1, -1, -1, -1 };
  return &_AndroidDatabaseSqliteSQLiteSession_Transaction;
}

@end

void AndroidDatabaseSqliteSQLiteSession_Transaction_init(AndroidDatabaseSqliteSQLiteSession_Transaction *self) {
  NSObject_init(self);
}

AndroidDatabaseSqliteSQLiteSession_Transaction *new_AndroidDatabaseSqliteSQLiteSession_Transaction_init() {
  J2OBJC_NEW_IMPL(AndroidDatabaseSqliteSQLiteSession_Transaction, init)
}

AndroidDatabaseSqliteSQLiteSession_Transaction *create_AndroidDatabaseSqliteSQLiteSession_Transaction_init() {
  J2OBJC_CREATE_IMPL(AndroidDatabaseSqliteSQLiteSession_Transaction, init)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(AndroidDatabaseSqliteSQLiteSession_Transaction)
