//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//

#include "J2ObjC_source.h"
#include "RxExceptionsExceptions.h"
#include "RxInternalOperatorsBlockingOperatorToFuture.h"
#include "RxInternalUtilBlockingUtils.h"
#include "RxObservable.h"
#include "RxSingle.h"
#include "RxSingleSubscriber.h"
#include "RxSinglesBlockingSingle.h"
#include "RxSubscription.h"
#include "java/lang/RuntimeException.h"
#include "java/util/concurrent/CountDownLatch.h"
#include "java/util/concurrent/Future.h"
#include "java/util/concurrent/atomic/AtomicReference.h"

@interface RxSinglesBlockingSingle () {
 @public
  RxSingle *single_;
}

- (instancetype)initWithRxSingle:(RxSingle *)single;

@end

J2OBJC_FIELD_SETTER(RxSinglesBlockingSingle, single_, RxSingle *)

__attribute__((unused)) static void RxSinglesBlockingSingle_initWithRxSingle_(RxSinglesBlockingSingle *self, RxSingle *single);

__attribute__((unused)) static RxSinglesBlockingSingle *new_RxSinglesBlockingSingle_initWithRxSingle_(RxSingle *single) NS_RETURNS_RETAINED;

__attribute__((unused)) static RxSinglesBlockingSingle *create_RxSinglesBlockingSingle_initWithRxSingle_(RxSingle *single);

@interface RxSinglesBlockingSingle_1 : RxSingleSubscriber {
 @public
  JavaUtilConcurrentAtomicAtomicReference *val$returnItem_;
  JavaUtilConcurrentCountDownLatch *val$latch_;
  JavaUtilConcurrentAtomicAtomicReference *val$returnException_;
}

- (instancetype)initWithJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$0
                           withJavaUtilConcurrentCountDownLatch:(JavaUtilConcurrentCountDownLatch *)capture$1
                    withJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$2;

- (void)onSuccessWithId:(id)value;

- (void)onErrorWithNSException:(NSException *)error;

@end

J2OBJC_EMPTY_STATIC_INIT(RxSinglesBlockingSingle_1)

__attribute__((unused)) static void RxSinglesBlockingSingle_1_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_(RxSinglesBlockingSingle_1 *self, JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2);

__attribute__((unused)) static RxSinglesBlockingSingle_1 *new_RxSinglesBlockingSingle_1_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2) NS_RETURNS_RETAINED;

__attribute__((unused)) static RxSinglesBlockingSingle_1 *create_RxSinglesBlockingSingle_1_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2);

@implementation RxSinglesBlockingSingle

- (instancetype)initWithRxSingle:(RxSingle *)single {
  RxSinglesBlockingSingle_initWithRxSingle_(self, single);
  return self;
}

+ (RxSinglesBlockingSingle *)fromWithRxSingle:(RxSingle *)single {
  return RxSinglesBlockingSingle_fromWithRxSingle_(single);
}

- (id)value {
  JavaUtilConcurrentAtomicAtomicReference *returnItem = create_JavaUtilConcurrentAtomicAtomicReference_init();
  JavaUtilConcurrentAtomicAtomicReference *returnException = create_JavaUtilConcurrentAtomicAtomicReference_init();
  JavaUtilConcurrentCountDownLatch *latch = create_JavaUtilConcurrentCountDownLatch_initWithInt_(1);
  id<RxSubscription> subscription = [((RxSingle *) nil_chk(single_)) subscribeWithRxSingleSubscriber:create_RxSinglesBlockingSingle_1_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_(returnItem, latch, returnException)];
  RxInternalUtilBlockingUtils_awaitForCompleteWithJavaUtilConcurrentCountDownLatch_withRxSubscription_(latch, subscription);
  NSException *throwable = [returnException get];
  if (throwable != nil) {
    @throw RxExceptionsExceptions_propagateWithNSException_(throwable);
  }
  return [returnItem get];
}

- (id<JavaUtilConcurrentFuture>)toFuture {
  return RxInternalOperatorsBlockingOperatorToFuture_toFutureWithRxObservable_([((RxSingle *) nil_chk((single_))) toObservable]);
}

- (void)dealloc {
  RELEASE_(single_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x2, -1, 0, -1, 1, -1, -1 },
    { NULL, "LRxSinglesBlockingSingle;", 0x9, 2, 0, -1, 3, -1, -1 },
    { NULL, "LNSObject;", 0x1, -1, -1, -1, 4, -1, -1 },
    { NULL, "LJavaUtilConcurrentFuture;", 0x1, -1, -1, -1, 5, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithRxSingle:);
  methods[1].selector = @selector(fromWithRxSingle:);
  methods[2].selector = @selector(value);
  methods[3].selector = @selector(toFuture);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "single_", "LRxSingle;", .constantValue.asLong = 0, 0x12, -1, -1, 6, -1 },
  };
  static const void *ptrTable[] = { "LRxSingle;", "(Lrx/Single<+TT;>;)V", "from", "<T:Ljava/lang/Object;>(Lrx/Single<+TT;>;)Lrx/singles/BlockingSingle<TT;>;", "()TT;", "()Ljava/util/concurrent/Future<TT;>;", "Lrx/Single<+TT;>;", "<T:Ljava/lang/Object;>Ljava/lang/Object;" };
  static const J2ObjcClassInfo _RxSinglesBlockingSingle = { "BlockingSingle", "rx.singles", ptrTable, methods, fields, 7, 0x11, 4, 1, -1, -1, -1, 7, -1 };
  return &_RxSinglesBlockingSingle;
}

@end

void RxSinglesBlockingSingle_initWithRxSingle_(RxSinglesBlockingSingle *self, RxSingle *single) {
  NSObject_init(self);
  JreStrongAssign(&self->single_, single);
}

RxSinglesBlockingSingle *new_RxSinglesBlockingSingle_initWithRxSingle_(RxSingle *single) {
  J2OBJC_NEW_IMPL(RxSinglesBlockingSingle, initWithRxSingle_, single)
}

RxSinglesBlockingSingle *create_RxSinglesBlockingSingle_initWithRxSingle_(RxSingle *single) {
  J2OBJC_CREATE_IMPL(RxSinglesBlockingSingle, initWithRxSingle_, single)
}

RxSinglesBlockingSingle *RxSinglesBlockingSingle_fromWithRxSingle_(RxSingle *single) {
  RxSinglesBlockingSingle_initialize();
  return create_RxSinglesBlockingSingle_initWithRxSingle_(single);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(RxSinglesBlockingSingle)

@implementation RxSinglesBlockingSingle_1

- (instancetype)initWithJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$0
                           withJavaUtilConcurrentCountDownLatch:(JavaUtilConcurrentCountDownLatch *)capture$1
                    withJavaUtilConcurrentAtomicAtomicReference:(JavaUtilConcurrentAtomicAtomicReference *)capture$2 {
  RxSinglesBlockingSingle_1_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_(self, capture$0, capture$1, capture$2);
  return self;
}

- (void)onSuccessWithId:(id)value {
  [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(val$returnItem_)) setWithId:value];
  [((JavaUtilConcurrentCountDownLatch *) nil_chk(val$latch_)) countDown];
}

- (void)onErrorWithNSException:(NSException *)error {
  [((JavaUtilConcurrentAtomicAtomicReference *) nil_chk(val$returnException_)) setWithId:error];
  [((JavaUtilConcurrentCountDownLatch *) nil_chk(val$latch_)) countDown];
}

- (void)dealloc {
  RELEASE_(val$returnItem_);
  RELEASE_(val$latch_);
  RELEASE_(val$returnException_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 0, 1, -1, 2, -1, -1 },
    { NULL, "V", 0x1, 3, 4, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  methods[0].selector = @selector(initWithJavaUtilConcurrentAtomicAtomicReference:withJavaUtilConcurrentCountDownLatch:withJavaUtilConcurrentAtomicAtomicReference:);
  methods[1].selector = @selector(onSuccessWithId:);
  methods[2].selector = @selector(onErrorWithNSException:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "val$returnItem_", "LJavaUtilConcurrentAtomicAtomicReference;", .constantValue.asLong = 0, 0x1012, -1, -1, 5, -1 },
    { "val$latch_", "LJavaUtilConcurrentCountDownLatch;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "val$returnException_", "LJavaUtilConcurrentAtomicAtomicReference;", .constantValue.asLong = 0, 0x1012, -1, -1, 6, -1 },
  };
  static const void *ptrTable[] = { "onSuccess", "LNSObject;", "(TT;)V", "onError", "LNSException;", "Ljava/util/concurrent/atomic/AtomicReference<TT;>;", "Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/Throwable;>;", "LRxSinglesBlockingSingle;", "value", "Lrx/SingleSubscriber<TT;>;" };
  static const J2ObjcClassInfo _RxSinglesBlockingSingle_1 = { "", "rx.singles", ptrTable, methods, fields, 7, 0x8018, 3, 3, 7, -1, 8, 9, -1 };
  return &_RxSinglesBlockingSingle_1;
}

@end

void RxSinglesBlockingSingle_1_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_(RxSinglesBlockingSingle_1 *self, JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2) {
  JreStrongAssign(&self->val$returnItem_, capture$0);
  JreStrongAssign(&self->val$latch_, capture$1);
  JreStrongAssign(&self->val$returnException_, capture$2);
  RxSingleSubscriber_init(self);
}

RxSinglesBlockingSingle_1 *new_RxSinglesBlockingSingle_1_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2) {
  J2OBJC_NEW_IMPL(RxSinglesBlockingSingle_1, initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_, capture$0, capture$1, capture$2)
}

RxSinglesBlockingSingle_1 *create_RxSinglesBlockingSingle_1_initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_(JavaUtilConcurrentAtomicAtomicReference *capture$0, JavaUtilConcurrentCountDownLatch *capture$1, JavaUtilConcurrentAtomicAtomicReference *capture$2) {
  J2OBJC_CREATE_IMPL(RxSinglesBlockingSingle_1, initWithJavaUtilConcurrentAtomicAtomicReference_withJavaUtilConcurrentCountDownLatch_withJavaUtilConcurrentAtomicAtomicReference_, capture$0, capture$1, capture$2)
}
